
ERROR: build step 4 "gcr.io/cloud-builders/docker" failed: step exited with non-zero status: 101
ERROR
Finished Step #4 - "build-docker"
The command '/bin/sh -c cargo build --release --bin minimal' returned a non-zero code: 101
error: could not compile `coditect-minimal-api` (lib) due to 346 previous errors; 28 warnings emitted
warning: `coditect-minimal-api` (lib) generated 28 warnings
For more information about an error, try `rustc --explain E0038`.
Some errors have detailed explanations: E0038, E0061, E0271, E0277, E0282, E0308, E0408, E0412, E0422...

   = help: if you wanted to use a crate named `lru`, use `cargo add lru` to add it to your `Cargo.toml`
   |
   |                                       ^^^ use of unresolved module or unlinked crate `lru`
13 |     redaction_cache: std::sync::Mutex<lru::LruCache<String, String>>,
   |
  --> src/memory/privacy.rs:13:39
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `lru`

    = help: if you wanted to use a crate named `urlencoding`, use `cargo add urlencoding` to add it to your `Cargo.toml`
    |
    |             ^^^^^^^^^^^ use of unresolved module or unlinked crate `urlencoding`
130 |             urlencoding::encode(state)
    |
   --> src/auth/oauth2_service.rs:130:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `urlencoding`

    = help: if you wanted to use a crate named `urlencoding`, use `cargo add urlencoding` to add it to your `Cargo.toml`
    |
    |             ^^^^^^^^^^^ use of unresolved module or unlinked crate `urlencoding`
129 |             urlencoding::encode(&self.config.redirect_uri),
    |
   --> src/auth/oauth2_service.rs:129:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `urlencoding`

    = help: if you wanted to use a crate named `urlencoding`, use `cargo add urlencoding` to add it to your `Cargo.toml`
    |
    |             ^^^^^^^^^^^ use of unresolved module or unlinked crate `urlencoding`
128 |             urlencoding::encode(&self.config.client_id),
    |
   --> src/auth/oauth2_service.rs:128:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `urlencoding`

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                                                 ^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
 25 |     providers: Arc<RwLock<HashMap<Provider, Arc<dyn AIProvider>>>>,
    |
   --> src/ai/router/mod.rs:25:49
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    |                                        ^^^^^^ help: if this is intentional, prefix it with an underscore: `_offset`
159 |     async fn write(&self, path: &Path, offset: u64, data: &[u8]) -> Result<u32> {
    |
   --> src/storage/gcs_fuse.rs:159:40
warning: unused variable: `offset`

    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_gcs_path`
145 |         let gcs_path = self.to_gcs_path(path);
    |
   --> src/storage/gcs_fuse.rs:145:13
warning: unused variable: `gcs_path`

    = note: available fields are: `timestamp`, `metrics`, `health`
    |
    |                                                    ^^^^^^^^^ unknown field
101 |                         serde_json::json!(snapshot.anomalies.len()),
    |
   --> src/services/system_monitor/metrics.rs:101:52
error[E0609]: no field `anomalies` on type `system_monitor::types::SystemSnapshot`

   = note: available fields are: `timestamp`, `metrics`, `health`
   |
   |                                                    ^^^^^^^^^^^^^ unknown field
97 |                         serde_json::json!(snapshot.active_alerts.len()),
   |
  --> src/services/system_monitor/metrics.rs:97:52
error[E0609]: no field `active_alerts` on type `system_monitor::types::SystemSnapshot`

   = note: available fields are: `timestamp`, `metrics`, `health`
   |
   |                                                    ^^^^^^^^^^^^^^ unknown field
93 |                         serde_json::json!(snapshot.top_operations.len()),
   |
  --> src/services/system_monitor/metrics.rs:93:52
error[E0609]: no field `top_operations` on type `system_monitor::types::SystemSnapshot`

   = note: available fields are: `health`
   |
   |                 ^^^^^^^^^^^^ `system_monitor::types::SystemSnapshot` does not have this field
83 |                 audit_events: vec![],
   |
  --> src/services/system_monitor/metrics.rs:83:17
error[E0560]: struct `system_monitor::types::SystemSnapshot` has no field named `audit_events`

   = note: available fields are: `health`
   |
   |                 ^^^^^^^^^ `system_monitor::types::SystemSnapshot` does not have this field
82 |                 anomalies: detect_anomalies(&event_buffer),
   |
  --> src/services/system_monitor/metrics.rs:82:17
error[E0560]: struct `system_monitor::types::SystemSnapshot` has no field named `anomalies`

   = note: available fields are: `health`
   |
   |                 ^^^^^^^^^^^^^^ `system_monitor::types::SystemSnapshot` does not have this field
81 |                 top_operations: calculate_top_operations(&event_buffer),
   |
  --> src/services/system_monitor/metrics.rs:81:17
error[E0560]: struct `system_monitor::types::SystemSnapshot` has no field named `top_operations`

   = note: available fields are: `health`
   |
   |                 ^^^^^^^^^^^^^ `system_monitor::types::SystemSnapshot` does not have this field
80 |                 active_alerts: vec![],
   |
  --> src/services/system_monitor/metrics.rs:80:17
error[E0560]: struct `system_monitor::types::SystemSnapshot` has no field named `active_alerts`

   = note: available fields are: `health`
   |
   |                 ^^^^^^^^^ `system_monitor::types::SystemSnapshot` does not have this field
78 |                 tenant_id,
   |
  --> src/services/system_monitor/metrics.rs:78:17
error[E0560]: struct `system_monitor::types::SystemSnapshot` has no field named `tenant_id`

   |                                               ++++++
30 |     m.memory_usage_mb = get_memory_usage_mb() as f32;
   |
help: you can cast a `u64` to an `f32`, producing the floating point representation of the integer, rounded if necessary
   |
   |     expected due to the type of this binding
   |     |
   |     -----------------   ^^^^^^^^^^^^^^^^^^^^^ expected `f32`, found `u64`
30 |     m.memory_usage_mb = get_memory_usage_mb();
   |
  --> src/services/system_monitor/metrics.rs:30:25
error[E0308]: mismatched types

    = note: available fields are: `message`, `resolved`
    |
    |                     ^^^^ `system_monitor::types::Alert` does not have this field
122 |                     data: serde_json::json!({
    |
   --> src/services/system_monitor/alerts.rs:122:21
error[E0560]: struct `system_monitor::types::Alert` has no field named `data`

    = note: available fields are: `message`, `resolved`
    |
    |                     ^^^^^^^^^^^ `system_monitor::types::Alert` does not have this field
121 |                     description: sec_event.threat_indicators.join(", "),
    |
   --> src/services/system_monitor/alerts.rs:121:21
error[E0560]: struct `system_monitor::types::Alert` has no field named `description`

    = note: available fields are: `message`, `resolved`
    |
    |                     ^^^^^ `system_monitor::types::Alert` does not have this field
120 |                     title: format!("{:?}", sec_event.event_type),
    |
   --> src/services/system_monitor/alerts.rs:120:21
error[E0560]: struct `system_monitor::types::Alert` has no field named `title`

   |
81 +                     for action in &rule.action {
81 -                     for action in &rule.actions {
   |
help: a field with a similar name exists
   |
   |                                         ^^^^^^^ unknown field
81 |                     for action in &rule.actions {
   |
  --> src/services/system_monitor/alerts.rs:81:41
error[E0609]: no field `actions` on type `system_monitor::types::AlertRule`

    = note: available fields are: `current_health`, `metrics_history`, `active_alerts`, `uptime_percent`
    |
    |             ^^^^^^^^^^^^^ `system_monitor::types::DashboardData` does not have this field
116 |             system_health,
    |
   --> src/services/system_monitor/core.rs:116:13
error[E0560]: struct `system_monitor::types::DashboardData` has no field named `system_health`

    = note: available fields are: `current_health`, `metrics_history`, `active_alerts`, `uptime_percent`
    |
    |             ^^^^^^^^^^^^^^^^^^^^^^ `system_monitor::types::DashboardData` does not have this field
115 |             recent_file_operations: recent_files,
    |
   --> src/services/system_monitor/core.rs:115:13
error[E0560]: struct `system_monitor::types::DashboardData` has no field named `recent_file_operations`

    = note: available fields are: `current_health`, `metrics_history`, `active_alerts`, `uptime_percent`
    |
    |             ^^^^^^^^^^^^^ `system_monitor::types::DashboardData` does not have this field
114 |             recent_alerts,
    |
   --> src/services/system_monitor/core.rs:114:13
error[E0560]: struct `system_monitor::types::DashboardData` has no field named `recent_alerts`

    = note: available fields are: `current_health`, `metrics_history`, `active_alerts`, `uptime_percent`
    |
    |             ^^^^^^^ `system_monitor::types::DashboardData` does not have this field
113 |             metrics,
    |
   --> src/services/system_monitor/core.rs:113:13
error[E0560]: struct `system_monitor::types::DashboardData` has no field named `metrics`

    | ------------------------ associated item `Create` not found for this struct
  7 | pub struct FileOperation {
    |
   ::: src/services/file_monitor/types.rs:7:1
    |
    |                                       ^^^^^^ associated item not found in `file_monitor::types::FileOperation`
177 |             operation: FileOperation::Create,
    |
   --> src/services/file_monitor/operations.rs:177:39
error[E0599]: no associated item named `Create` found for struct `file_monitor::types::FileOperation` in the current scope

    | ------------------------ associated item `Update` not found for this struct
  7 | pub struct FileOperation {
    |
   ::: src/services/file_monitor/types.rs:7:1
    |
    |                                           ^^^^^^ associated item not found in `file_monitor::types::FileOperation`
148 |                 operation: FileOperation::Update,
    |
   --> src/services/file_monitor/operations.rs:148:43
error[E0599]: no associated item named `Update` found for struct `file_monitor::types::FileOperation` in the current scope

    | ------------------------ associated item `Delete` not found for this struct
  7 | pub struct FileOperation {
    |
   ::: src/services/file_monitor/types.rs:7:1
    |
    |                                           ^^^^^^ associated item not found in `file_monitor::types::FileOperation`
105 |                 operation: FileOperation::Delete,
    |
   --> src/services/file_monitor/operations.rs:105:43
error[E0599]: no associated item named `Delete` found for struct `file_monitor::types::FileOperation` in the current scope

   | ------------------------ associated item `Update` not found for this struct
 7 | pub struct FileOperation {
   |
  ::: src/services/file_monitor/types.rs:7:1
   |
   |                                               ^^^^^^ associated item not found in `file_monitor::types::FileOperation`
70 |                     operation: FileOperation::Update,
   |
  --> src/services/file_monitor/detection.rs:70:47
error[E0599]: no associated item named `Update` found for struct `file_monitor::types::FileOperation` in the current scope

   | ------------------------ associated item `Chown` not found for this struct
 7 | pub struct FileOperation {
   |
  ::: src/services/file_monitor/types.rs:7:1
   |
   |                                                                                             ^^^^^ associated item not found in `file_monitor::types::FileOperation`
73 |         FileOperation::Update | FileOperation::Move | FileOperation::Chmod | FileOperation::Chown
   |
  --> src/services/file_monitor/audit.rs:73:93
error[E0599]: no associated item named `Chown` found for struct `file_monitor::types::FileOperation` in the current scope

   | ------------------------ associated item `Chmod` not found for this struct
 7 | pub struct FileOperation {
   |
  ::: src/services/file_monitor/types.rs:7:1
   |
   |                                                                      ^^^^^ associated item not found in `file_monitor::types::FileOperation`
73 |         FileOperation::Update | FileOperation::Move | FileOperation::Chmod | FileOperation::Chown
   |
  --> src/services/file_monitor/audit.rs:73:70
error[E0599]: no associated item named `Chmod` found for struct `file_monitor::types::FileOperation` in the current scope

   | ------------------------ associated item `Move` not found for this struct
 7 | pub struct FileOperation {
   |
  ::: src/services/file_monitor/types.rs:7:1
   |
   |                                                ^^^^ associated item not found in `file_monitor::types::FileOperation`
73 |         FileOperation::Update | FileOperation::Move | FileOperation::Chmod | FileOperation::Chown
   |
  --> src/services/file_monitor/audit.rs:73:48
error[E0599]: no associated item named `Move` found for struct `file_monitor::types::FileOperation` in the current scope

   | ------------------------ associated item `Update` not found for this struct
 7 | pub struct FileOperation {
   |
  ::: src/services/file_monitor/types.rs:7:1
   |
   |                        ^^^^^^ associated item not found in `file_monitor::types::FileOperation`
73 |         FileOperation::Update | FileOperation::Move | FileOperation::Chmod | FileOperation::Chown
   |
  --> src/services/file_monitor/audit.rs:73:24
error[E0599]: no associated item named `Update` found for struct `file_monitor::types::FileOperation` in the current scope

   | ------------------------ associated item `Unlink` not found for this struct
 7 | pub struct FileOperation {
   |
  ::: src/services/file_monitor/types.rs:7:1
   |
   |                                              ^^^^^^ associated item not found in `file_monitor::types::FileOperation`
67 |         FileOperation::Link | FileOperation::Unlink => DataOperation::Update,
   |
  --> src/services/file_monitor/audit.rs:67:46
error[E0599]: no associated item named `Unlink` found for struct `file_monitor::types::FileOperation` in the current scope

   | ------------------------ associated item `Link` not found for this struct
 7 | pub struct FileOperation {
   |
  ::: src/services/file_monitor/types.rs:7:1
   |
   |                        ^^^^ associated item not found in `file_monitor::types::FileOperation`
67 |         FileOperation::Link | FileOperation::Unlink => DataOperation::Update,
   |
  --> src/services/file_monitor/audit.rs:67:24
error[E0599]: no associated item named `Link` found for struct `file_monitor::types::FileOperation` in the current scope

   | ------------------------ associated item `Chown` not found for this struct
 7 | pub struct FileOperation {
   |
  ::: src/services/file_monitor/types.rs:7:1
   |
   |                                               ^^^^^ associated item not found in `file_monitor::types::FileOperation`
66 |         FileOperation::Chmod | FileOperation::Chown => DataOperation::Update,
   |
  --> src/services/file_monitor/audit.rs:66:47
error[E0599]: no associated item named `Chown` found for struct `file_monitor::types::FileOperation` in the current scope

   | ------------------------ associated item `Chmod` not found for this struct
 7 | pub struct FileOperation {
   |
  ::: src/services/file_monitor/types.rs:7:1
   |
   |                        ^^^^^ associated item not found in `file_monitor::types::FileOperation`
66 |         FileOperation::Chmod | FileOperation::Chown => DataOperation::Update,
   |
  --> src/services/file_monitor/audit.rs:66:24
error[E0599]: no associated item named `Chmod` found for struct `file_monitor::types::FileOperation` in the current scope

   | ------------------------ associated item `Copy` not found for this struct
 7 | pub struct FileOperation {
   |
  ::: src/services/file_monitor/types.rs:7:1
   |
   |                        ^^^^ associated item not found in `file_monitor::types::FileOperation`
65 |         FileOperation::Copy => DataOperation::Create,
   |
  --> src/services/file_monitor/audit.rs:65:24
error[E0599]: no associated item named `Copy` found for struct `file_monitor::types::FileOperation` in the current scope

   | ------------------------ associated item `Move` not found for this struct
 7 | pub struct FileOperation {
   |
  ::: src/services/file_monitor/types.rs:7:1
   |
   |                        ^^^^ associated item not found in `file_monitor::types::FileOperation`
64 |         FileOperation::Move => DataOperation::Update,
   |
  --> src/services/file_monitor/audit.rs:64:24
error[E0599]: no associated item named `Move` found for struct `file_monitor::types::FileOperation` in the current scope

   | ------------------------ associated item `Delete` not found for this struct
 7 | pub struct FileOperation {
   |
  ::: src/services/file_monitor/types.rs:7:1
   |
   |                        ^^^^^^ associated item not found in `file_monitor::types::FileOperation`
63 |         FileOperation::Delete => DataOperation::Delete,
   |
  --> src/services/file_monitor/audit.rs:63:24
error[E0599]: no associated item named `Delete` found for struct `file_monitor::types::FileOperation` in the current scope

   | ------------------------ associated item `Update` not found for this struct
 7 | pub struct FileOperation {
   |
  ::: src/services/file_monitor/types.rs:7:1
   |
   |                        ^^^^^^ associated item not found in `file_monitor::types::FileOperation`
62 |         FileOperation::Update => DataOperation::Update,
   |
  --> src/services/file_monitor/audit.rs:62:24
error[E0599]: no associated item named `Update` found for struct `file_monitor::types::FileOperation` in the current scope

   | ------------------------ associated item `Read` not found for this struct
 7 | pub struct FileOperation {
   |
  ::: src/services/file_monitor/types.rs:7:1
   |
   |                        ^^^^ associated item not found in `file_monitor::types::FileOperation`
61 |         FileOperation::Read => DataOperation::Read,
   |
  --> src/services/file_monitor/audit.rs:61:24
error[E0599]: no associated item named `Read` found for struct `file_monitor::types::FileOperation` in the current scope

   | ------------------------ associated item `Create` not found for this struct
 7 | pub struct FileOperation {
   |
  ::: src/services/file_monitor/types.rs:7:1
   |
   |                        ^^^^^^ associated item not found in `file_monitor::types::FileOperation`
60 |         FileOperation::Create => DataOperation::Create,
   |
  --> src/services/file_monitor/audit.rs:60:24
error[E0599]: no associated item named `Create` found for struct `file_monitor::types::FileOperation` in the current scope

    = note: consider using `--verbose` to print the full type name to the console
    = note: the full name for the type has been written to '/app/target/release/deps/coditect_minimal_api-6c7908efab1fbd6e.long-type-5280872466539215313.txt'
                      found enum `std::result::Result<_, _>`
    = note: expected opaque type `impl futures::Future<Output = std::result::Result<R, anyhow::Error>>`
    |
    |                     ^^^^^^ expected future, found `Result<_, _>`
105 |               Ok(Ok(Err(e))) => Err(e),
104 |               Ok(Ok(Ok(result))) => Ok(result),
    | |_______________- this expression has type `Result<Result<impl Future<Output = Result<R, Error>>, JoinError>, ...>`
103 | |         ).await {
102 | |             handle
101 | |             tokio::time::Duration::from_secs(30),
    |  _______________-
100 |           match tokio::time::timeout(
    |
   --> src/security/tenant_isolation.rs:105:19
error[E0308]: mismatched types

    = note: consider using `--verbose` to print the full type name to the console
    = note: the full name for the type has been written to '/app/target/release/deps/coditect_minimal_api-6c7908efab1fbd6e.long-type-5280872466539215313.txt'
                      found enum `std::result::Result<_, _>`
    = note: expected opaque type `impl futures::Future<Output = std::result::Result<R, anyhow::Error>>`
    |
    |                     ^^^^^^^^^^ expected future, found `Result<_, _>`
104 |               Ok(Ok(Ok(result))) => Ok(result),
    | |_______________- this expression has type `Result<Result<impl Future<Output = Result<R, Error>>, JoinError>, ...>`
103 | |         ).await {
102 | |             handle
101 | |             tokio::time::Duration::from_secs(30),
    |  _______________-
100 |           match tokio::time::timeout(
    |
   --> src/security/tenant_isolation.rs:104:19
error[E0308]: mismatched types

    |                                                        ^^^^
297 |             if now.date() != usage.last_ai_token_reset.date() {
    |
   --> src/security/resource_quotas.rs:297:56
warning: use of deprecated method `chrono::DateTime::<Tz>::date`: Use `date_naive()` instead

    |                    ^^^^
297 |             if now.date() != usage.last_ai_token_reset.date() {
    |
   --> src/security/resource_quotas.rs:297:20
warning: use of deprecated method `chrono::DateTime::<Tz>::date`: Use `date_naive()` instead

    |                                                   ^^^^
290 |             if now.date() != usage.last_api_reset.date() {
    |
   --> src/security/resource_quotas.rs:290:51
warning: use of deprecated method `chrono::DateTime::<Tz>::date`: Use `date_naive()` instead

    |                    ^^^^
290 |             if now.date() != usage.last_api_reset.date() {
    |
   --> src/security/resource_quotas.rs:290:20
warning: use of deprecated method `chrono::DateTime::<Tz>::date`: Use `date_naive()` instead

    |                                                    ^^^^
243 |         if now.date() != usage.last_ai_token_reset.date() {
    |
   --> src/security/resource_quotas.rs:243:52
warning: use of deprecated method `chrono::DateTime::<Tz>::date`: Use `date_naive()` instead

    |                ^^^^
243 |         if now.date() != usage.last_ai_token_reset.date() {
    |
   --> src/security/resource_quotas.rs:243:16
warning: use of deprecated method `chrono::DateTime::<Tz>::date`: Use `date_naive()` instead

    |                                               ^^^^
211 |         if now.date() != usage.last_api_reset.date() {
    |
   --> src/security/resource_quotas.rs:211:47
warning: use of deprecated method `chrono::DateTime::<Tz>::date`: Use `date_naive()` instead

    = note: `#[warn(deprecated)]` on by default
    |
    |                ^^^^
211 |         if now.date() != usage.last_api_reset.date() {
    |
   --> src/security/resource_quotas.rs:211:16
warning: use of deprecated method `chrono::DateTime::<Tz>::date`: Use `date_naive()` instead

   = note: consider using `--verbose` to print the full type name to the console
   = note: the full name for the type has been written to '/app/target/release/deps/coditect_minimal_api-6c7908efab1fbd6e.long-type-7661467700737630000.txt'
              found struct `ServiceResponse<EitherBody<actix_web::middleware::logger::StreamLog<BoxBody>>>`
   = note: expected struct `ServiceResponse<BoxBody>`
   |
   | |_________- return type was inferred to be `App<...>` here
51 | |         )
50 | |                 .route("/tasks", web::get().to(handlers::list_tasks))
...  |
25 | |             Cors::default()
24 | |         .wrap(
23 | |         .wrap(Logger::default())
22 | /     App::new()
21 |   > {
   | |_____^ expected `ServiceResponse`, found `ServiceResponse<EitherBody<...>>`
20 | |     >,
19 | |         InitError = (),
18 | |         Error = actix_web::Error,
17 | |         Response = actix_web::dev::ServiceResponse<actix_web::body::BoxBody>,
16 | |         Config = (),
15 | |         actix_web::dev::ServiceRequest,
14 | /     impl actix_web::dev::ServiceFactory<
   |
  --> src/minimal/mod.rs:14:5
error[E0271]: type mismatch resolving `<impl ServiceFactory<..., Config = (), Response = ..., Error = ..., InitError = ()> as ServiceFactory<...>>::Response == ServiceResponse`

   --> /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/option.rs:601:5
note: required by a bound in `std::prelude::v1::Some`
    = help: the trait `std::marker::Sized` is not implemented for `str`
    |
    |                    ^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
280 |             if let Some(session_id) = conn.connection.session_id {
    |
   --> src/gateway/websocket_server_with_memory.rs:280:20
error[E0277]: the size for values of type `str` cannot be known at compilation time

   --> /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/option.rs:601:5
note: required by a bound in `std::prelude::v1::Some`
    = help: the trait `std::marker::Sized` is not implemented for `str`
    |
    |                    ^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
218 |             if let Some(session_id) = conn.session_id {
    |
   --> src/gateway/websocket_server.rs:218:20
error[E0277]: the size for values of type `str` cannot be known at compilation time

   --> /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/option.rs:593:1
note: required by an implicit `Sized` bound in `std::option::Option`
    = help: the trait `std::marker::Sized` is not implemented for `str`
    |
    |                               ^^^^^^^^^ doesn't have a size known at compile-time
197 |             for session_id in to_remove {
    |
   --> src/gateway/terminal_bridge/bridge.rs:197:31
error[E0277]: the size for values of type `str` cannot be known at compilation time

   --> /rustc/1159e78c4747b02ef996e55082b704c09b970588/library/core/src/option.rs:597:5
note: required by a bound in `std::prelude::v1::None`
    = help: the trait `std::marker::Sized` is not implemented for `str`
    |
    | |_____________^ doesn't have a size known at compile-time
201 | |             }
200 | |                 }
199 | |                     error!("Failed to close inactive session {}: {}", session_id, e);
198 | |                 if let Err(e) = self.close_session(&session_id).await {
197 | /             for session_id in to_remove {
    |
   --> src/gateway/terminal_bridge/bridge.rs:197:13
error[E0277]: the size for values of type `str` cannot be known at compilation time

    = note: all local variables must have a statically known size
    = help: the trait `std::marker::Sized` is not implemented for `str`
    |
    |                 ^^^^^^^^^^ doesn't have a size known at compile-time
197 |             for session_id in to_remove {
    |
   --> src/gateway/terminal_bridge/bridge.rs:197:17
error[E0277]: the size for values of type `str` cannot be known at compilation time

   = note: available fields are: `id`, `tenant_id`, `entity_id`, `subsidiary_id`, `name` ... and 17 others
   |
   |                                                                      ^^^^^^^^^^ unknown field
63 |         let key = KeyBuilder::project_key(project.tenant_id, project.project_id);
   |
  --> src/db/repositories/project_repository.rs:63:70
error[E0609]: no field `project_id` on type `&Project`

   = note: available fields are: `id`, `tenant_id`, `entity_id`, `subsidiary_id`, `name` ... and 17 others
   |
   |                     ^^^^^^^^^^ unknown field
37 |             project.project_id,
   |
  --> src/db/repositories/project_repository.rs:37:21
error[E0609]: no field `project_id` on type `&Project`

   = note: available fields are: `id`, `tenant_id`, `entity_id`, `subsidiary_id`, `name` ... and 17 others
   |
   |                     ^^^^^^^^^^ unknown field
30 |             project.project_id,
   |
  --> src/db/repositories/project_repository.rs:30:21
error[E0609]: no field `project_id` on type `&Project`

   = note: available fields are: `id`, `tenant_id`, `entity_id`, `subsidiary_id`, `name` ... and 17 others
   |
   |                                                                      ^^^^^^^^^^ unknown field
22 |         let key = KeyBuilder::project_key(project.tenant_id, project.project_id);
   |
  --> src/db/repositories/project_repository.rs:22:70
error[E0609]: no field `project_id` on type `&Project`

    = help: if you wanted to use a crate named `bincode`, use `cargo add bincode` to add it to your `Cargo.toml`
    |
    |                                         ^^^^^^^ use of unresolved module or unlinked crate `bincode`
268 |             let event: LifecycleEvent = bincode::deserialize(kv.value())?;
    |
   --> src/db/repositories/agent_instance_repository.rs:268:41
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `bincode`

    = help: if you wanted to use a crate named `bincode`, use `cargo add bincode` to add it to your `Cargo.toml`
    |
    |                     ^^^^^^^ use of unresolved module or unlinked crate `bincode`
240 |         let value = bincode::serialize(event)?;
    |
   --> src/db/repositories/agent_instance_repository.rs:240:21
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `bincode`

    = help: if you wanted to use a crate named `bincode`, use `cargo add bincode` to add it to your `Cargo.toml`
    |
    |                                           ^^^^^^^ use of unresolved module or unlinked crate `bincode`
139 |             let instance: AgentInstance = bincode::deserialize(kv.value())?;
    |
   --> src/db/repositories/agent_instance_repository.rs:139:43
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `bincode`

    = help: if you wanted to use a crate named `bincode`, use `cargo add bincode` to add it to your `Cargo.toml`
    |
    |                                           ^^^^^^^ use of unresolved module or unlinked crate `bincode`
105 |             let instance: AgentInstance = bincode::deserialize(&value)?;
    |
   --> src/db/repositories/agent_instance_repository.rs:105:43
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `bincode`

   = help: if you wanted to use a crate named `bincode`, use `cargo add bincode` to add it to your `Cargo.toml`
   |
   |                     ^^^^^^^ use of unresolved module or unlinked crate `bincode`
89 |         let value = bincode::serialize(instance)?;
   |
  --> src/db/repositories/agent_instance_repository.rs:89:21
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `bincode`

   = help: if you wanted to use a crate named `bincode`, use `cargo add bincode` to add it to your `Cargo.toml`
   |
   |                                               ^^^^^^^ use of unresolved module or unlinked crate `bincode`
67 |             let old_instance: AgentInstance = bincode::deserialize(&old_value)?;
   |
  --> src/db/repositories/agent_instance_repository.rs:67:47
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `bincode`

   = help: if you wanted to use a crate named `bincode`, use `cargo add bincode` to add it to your `Cargo.toml`
   |
   |                                    ^^^^^^^ use of unresolved module or unlinked crate `bincode`
55 |             Some(value) => Ok(Some(bincode::deserialize(&value)?)),
   |
  --> src/db/repositories/agent_instance_repository.rs:55:36
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `bincode`

   = help: if you wanted to use a crate named `bincode`, use `cargo add bincode` to add it to your `Cargo.toml`
   |
   |                     ^^^^^^^ use of unresolved module or unlinked crate `bincode`
24 |         let value = bincode::serialize(instance)?;
   |
  --> src/db/repositories/agent_instance_repository.rs:24:21
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `bincode`

    = help: if you wanted to use a crate named `bincode`, use `cargo add bincode` to add it to your `Cargo.toml`
    |
    |                                             ^^^^^^^ use of unresolved module or unlinked crate `bincode`
161 |             let execution: AgentExecution = bincode::deserialize(kv.value())?;
    |
   --> src/db/repositories/agent_execution_repository.rs:161:45
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `bincode`

    = help: if you wanted to use a crate named `bincode`, use `cargo add bincode` to add it to your `Cargo.toml`
    |
    |                                             ^^^^^^^ use of unresolved module or unlinked crate `bincode`
113 |             let execution: AgentExecution = bincode::deserialize(&value)?;
    |
   --> src/db/repositories/agent_execution_repository.rs:113:45
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `bincode`

   = help: if you wanted to use a crate named `bincode`, use `cargo add bincode` to add it to your `Cargo.toml`
   |
   |                     ^^^^^^^ use of unresolved module or unlinked crate `bincode`
97 |         let value = bincode::serialize(execution)?;
   |
  --> src/db/repositories/agent_execution_repository.rs:97:21
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `bincode`

   = help: if you wanted to use a crate named `bincode`, use `cargo add bincode` to add it to your `Cargo.toml`
   |
   |                                                 ^^^^^^^ use of unresolved module or unlinked crate `bincode`
75 |             let old_execution: AgentExecution = bincode::deserialize(&old_value)?;
   |
  --> src/db/repositories/agent_execution_repository.rs:75:49
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `bincode`

   = help: if you wanted to use a crate named `bincode`, use `cargo add bincode` to add it to your `Cargo.toml`
   |
   |                                    ^^^^^^^ use of unresolved module or unlinked crate `bincode`
63 |             Some(value) => Ok(Some(bincode::deserialize(&value)?)),
   |
  --> src/db/repositories/agent_execution_repository.rs:63:36
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `bincode`

   = help: if you wanted to use a crate named `bincode`, use `cargo add bincode` to add it to your `Cargo.toml`
   |
   |                     ^^^^^^^ use of unresolved module or unlinked crate `bincode`
24 |         let value = bincode::serialize(execution)?;
   |
  --> src/db/repositories/agent_execution_repository.rs:24:21
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `bincode`

    |                    ++++
414 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
414 | |         .extensions()
    |  _____________________-
413 |       let tenant_id = req
    |
   --> src/api/handlers/user.rs:414:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

    |                    ++++
379 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
379 | |         .extensions()
    |  _____________________-
378 |       let tenant_id = req
    |
   --> src/api/handlers/user.rs:379:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

    |                    ++++
271 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
271 | |         .extensions()
    |  _____________________-
270 |       let tenant_id = req
    |
   --> src/api/handlers/user.rs:271:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

    |                    ++++
206 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
206 | |         .extensions()
    |  _____________________-
205 |       let tenant_id = req
    |
   --> src/api/handlers/user.rs:206:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

   | -------------------------- method `list_by_tenant` not found for this struct
11 | pub struct UsageRepository {
   |
  ::: src/db/repositories/usage_repository.rs:11:1
   |
   |                      ^^^^^^^^^^^^^^ method not found in `UsageRepository`
24 |     match usage_repo.list_by_tenant(&tenant_id).await {
   |
  --> src/api/handlers/usage.rs:24:22
error[E0599]: no method named `list_by_tenant` found for struct `UsageRepository` in the current scope

   |                      ^^^^ method not found in `std::sync::Arc<Database>`
20 |     let db = data.db.lock().await;
   |
  --> src/api/handlers/usage.rs:20:22
error[E0599]: no method named `lock` found for struct `std::sync::Arc<Database>` in the current scope

   |                    ++++
15 |         .extensions_mut()
   |
help: there is a method `extensions_mut` with a similar name
   |
 1 + use actix_web::HttpMessage;
   |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
   = help: items from traits can only be used if the trait is in scope
   |
   |          ---------- the method is available for `HttpRequest` here
29 |       fn extensions(&self) -> Ref<'_, Extensions>;
   |
  ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
   |
   | |_________-^^^^^^^^^^
15 | |         .extensions()
   |  _____________________-
14 |       let tenant_id = req
   |
  --> src/api/handlers/usage.rs:15:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

   |                    ++++
85 |         .extensions_mut()
   |
help: there is a method `extensions_mut` with a similar name
   |
 1 + use actix_web::HttpMessage;
   |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
   = help: items from traits can only be used if the trait is in scope
   |
   |          ---------- the method is available for `HttpRequest` here
29 |       fn extensions(&self) -> Ref<'_, Extensions>;
   |
  ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
   |
   | |_________-^^^^^^^^^^
85 | |         .extensions()
   |  _____________________-
84 |       let tenant_id = req
   |
  --> src/api/handlers/test.rs:85:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

   = note: `#[warn(unused_variables)]` on by default
   |
   |     ^^^^ help: if this is intentional, prefix it with an underscore: `_data`
27 |     data: web::Data<AppState>,
   |
  --> src/api/handlers/test.rs:27:5
warning: unused variable: `data`

    |
348 +     match repo.delete(/* uuid::Uuid */, /* uuid::Uuid */).await {
348 -     match repo.delete(&subsidiary_id).await {
    |
help: provide the argument
    |
348 +     match repo.delete(subsidiary_id).await {
348 -     match repo.delete(&subsidiary_id).await {
    |
help: consider removing the borrow
    |                  ^^^^^^        ---------------  -------------------
 69 |     pub async fn delete(&self, tenant_id: Uuid, subsidiary_id: Uuid) -> Result<bool> {
    |
   --> src/db/repositories/subsidiary_repository.rs:69:18
note: method defined here
    |
    |                      argument #2 of type `uuid::Uuid` is missing
    |                      |expected `Uuid`, found `&Uuid`
    |                      ||
    |                ^^^^^^----------------
348 |     match repo.delete(&subsidiary_id).await {
    |
   --> src/api/handlers/subsidiary.rs:348:16
error[E0061]: this method takes 2 arguments but 1 argument was supplied

    |
347 +     let repo = SubsidiaryRepository::new(data.db.clone());
347 -     let repo = SubsidiaryRepository::new(data.db.clone(), tenant_id);
    |
help: remove the extra argument
    |            ^^^
 15 |     pub fn new(db: Arc<Database>) -> Self {
    |
   --> src/db/repositories/subsidiary_repository.rs:15:12
note: associated function defined here
    |
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^                  --------- unexpected argument #2
347 |     let repo = SubsidiaryRepository::new(data.db.clone(), tenant_id);
    |
   --> src/api/handlers/subsidiary.rs:347:16
error[E0061]: this function takes 1 argument but 2 arguments were supplied

    |                    ++++
342 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
342 | |         .extensions()
    |  _____________________-
341 |       let tenant_id = req
    |
   --> src/api/handlers/subsidiary.rs:342:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

    |                       +++++++++++++++++
318 |     match repo.update(/* uuid::Uuid */, &subsidiary).await {
    |
help: provide the argument
    |                  ^^^^^^        ---------------
 45 |     pub async fn update(&self, tenant_id: Uuid, subsidiary: &Subsidiary) -> Result<bool> {
    |
   --> src/db/repositories/subsidiary_repository.rs:45:18
note: method defined here
    |
    |                ^^^^^^ ----------- argument #1 of type `uuid::Uuid` is missing
318 |     match repo.update(&subsidiary).await {
    |
   --> src/api/handlers/subsidiary.rs:318:16
error[E0061]: this method takes 2 arguments but 1 argument was supplied

    = note: available fields are: `subsidiary_id`, `entity_id`, `name`, `code`, `region` ... and 4 others
    |
    |                    ^^^^^^^^^ unknown field
314 |         subsidiary.is_active = is_active;
    |
   --> src/api/handlers/subsidiary.rs:314:20
error[E0609]: no field `is_active` on type `Subsidiary`

    = note: available fields are: `name`, `code`, `region`, `manager_id`, `status`
    = note: available field is: `0`
    |
    |                                   ^^^^^^^^^ unknown field
313 |     if let Some(is_active) = body.is_active {
    |
   --> src/api/handlers/subsidiary.rs:313:35
error[E0609]: no field `is_active` on type `actix_web::web::Json<UpdateSubsidiaryRequest>`

    |
286 +     let mut subsidiary = match repo.get(/* uuid::Uuid */, /* uuid::Uuid */).await {
286 -     let mut subsidiary = match repo.get(&subsidiary_id).await {
    |
help: provide the argument
    |
286 +     let mut subsidiary = match repo.get(subsidiary_id).await {
286 -     let mut subsidiary = match repo.get(&subsidiary_id).await {
    |
help: consider removing the borrow
    |                  ^^^        ---------------  -------------------
 32 |     pub async fn get(&self, tenant_id: Uuid, subsidiary_id: Uuid) -> Result<Option<Subsidiary>> {
    |
   --> src/db/repositories/subsidiary_repository.rs:32:18
note: method defined here
    |
    |                                        argument #2 of type `uuid::Uuid` is missing
    |                                        |expected `Uuid`, found `&Uuid`
    |                                        ||
    |                                     ^^^----------------
286 |     let mut subsidiary = match repo.get(&subsidiary_id).await {
    |
   --> src/api/handlers/subsidiary.rs:286:37
error[E0061]: this method takes 2 arguments but 1 argument was supplied

    |
283 +     let repo = SubsidiaryRepository::new(data.db.clone());
283 -     let repo = SubsidiaryRepository::new(data.db.clone(), tenant_id);
    |
help: remove the extra argument
    |            ^^^
 15 |     pub fn new(db: Arc<Database>) -> Self {
    |
   --> src/db/repositories/subsidiary_repository.rs:15:12
note: associated function defined here
    |
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^                  --------- unexpected argument #2
283 |     let repo = SubsidiaryRepository::new(data.db.clone(), tenant_id);
    |
   --> src/api/handlers/subsidiary.rs:283:16
error[E0061]: this function takes 1 argument but 2 arguments were supplied

    |                    ++++
278 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
278 | |         .extensions()
    |  _____________________-
277 |       let tenant_id = req
    |
   --> src/api/handlers/subsidiary.rs:278:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

    |
248 +     match repo.get(/* uuid::Uuid */, /* uuid::Uuid */).await {
248 -     match repo.get(&subsidiary_id).await {
    |
help: provide the argument
    |
248 +     match repo.get(subsidiary_id).await {
248 -     match repo.get(&subsidiary_id).await {
    |
help: consider removing the borrow
    |                  ^^^        ---------------  -------------------
 32 |     pub async fn get(&self, tenant_id: Uuid, subsidiary_id: Uuid) -> Result<Option<Subsidiary>> {
    |
   --> src/db/repositories/subsidiary_repository.rs:32:18
note: method defined here
    |
    |                   argument #2 of type `uuid::Uuid` is missing
    |                   |expected `Uuid`, found `&Uuid`
    |                   ||
    |                ^^^----------------
248 |     match repo.get(&subsidiary_id).await {
    |
   --> src/api/handlers/subsidiary.rs:248:16
error[E0061]: this method takes 2 arguments but 1 argument was supplied

    |
247 +     let repo = SubsidiaryRepository::new(data.db.clone());
247 -     let repo = SubsidiaryRepository::new(data.db.clone(), tenant_id);
    |
help: remove the extra argument
    |            ^^^
 15 |     pub fn new(db: Arc<Database>) -> Self {
    |
   --> src/db/repositories/subsidiary_repository.rs:15:12
note: associated function defined here
    |
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^                  --------- unexpected argument #2
247 |     let repo = SubsidiaryRepository::new(data.db.clone(), tenant_id);
    |
   --> src/api/handlers/subsidiary.rs:247:16
error[E0061]: this function takes 1 argument but 2 arguments were supplied

    |                    ++++
242 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
242 | |         .extensions()
    |  _____________________-
241 |       let tenant_id = req
    |
   --> src/api/handlers/subsidiary.rs:242:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

            candidate #1: `Directory`
    = note: the following trait defines an item `list`, perhaps you need to implement it:
    = help: items from traits can only be used if the trait is implemented and in scope
    |
    | ------------------------------- method `list` not found for this struct
 10 | pub struct SubsidiaryRepository {
    |
   ::: src/db/repositories/subsidiary_repository.rs:10:1
    |
    |                ^^^^ method not found in `SubsidiaryRepository`
218 |     match repo.list().await {
    |
   --> src/api/handlers/subsidiary.rs:218:16
error[E0599]: no method named `list` found for struct `SubsidiaryRepository` in the current scope

    |
217 +     let repo = SubsidiaryRepository::new(data.db.clone());
217 -     let repo = SubsidiaryRepository::new(data.db.clone(), tenant_id);
    |
help: remove the extra argument
    |            ^^^
 15 |     pub fn new(db: Arc<Database>) -> Self {
    |
   --> src/db/repositories/subsidiary_repository.rs:15:12
note: associated function defined here
    |
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^                  --------- unexpected argument #2
217 |     let repo = SubsidiaryRepository::new(data.db.clone(), tenant_id);
    |
   --> src/api/handlers/subsidiary.rs:217:16
error[E0061]: this function takes 1 argument but 2 arguments were supplied

    |                    ++++
212 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
212 | |         .extensions()
    |  _____________________-
211 |       let tenant_id = req
    |
   --> src/api/handlers/subsidiary.rs:212:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

    |                       +++++++++++++++++
191 |     match repo.create(/* uuid::Uuid */, &subsidiary).await {
    |
help: provide the argument
    |                  ^^^^^^        ---------------
 19 |     pub async fn create(&self, tenant_id: Uuid, subsidiary: &Subsidiary) -> Result<()> {
    |
   --> src/db/repositories/subsidiary_repository.rs:19:18
note: method defined here
    |
    |                ^^^^^^ ----------- argument #1 of type `uuid::Uuid` is missing
191 |     match repo.create(&subsidiary).await {
    |
   --> src/api/handlers/subsidiary.rs:191:16
error[E0061]: this method takes 2 arguments but 1 argument was supplied

    |
190 +     let repo = SubsidiaryRepository::new(data.db.clone());
190 -     let repo = SubsidiaryRepository::new(data.db.clone(), tenant_id);
    |
help: remove the extra argument
    |            ^^^
 15 |     pub fn new(db: Arc<Database>) -> Self {
    |
   --> src/db/repositories/subsidiary_repository.rs:15:12
note: associated function defined here
    |
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^                  --------- unexpected argument #2
190 |     let repo = SubsidiaryRepository::new(data.db.clone(), tenant_id);
    |
   --> src/api/handlers/subsidiary.rs:190:16
error[E0061]: this function takes 1 argument but 2 arguments were supplied

    |
183 +     let subsidiary = Subsidiary::new(tenant_id, /* std::string::String */, body.name.clone(), body.code.clone(), body.entity_id);
188 -     );
187 -         body.code.clone(),
186 -         body.name.clone(),
185 -         body.entity_id,
184 -         tenant_id,
183 -     let subsidiary = Subsidiary::new(
    |
help: provide the argument
    |         ------------
 28 |         name: String,
 27 |         entity_id: Uuid,
    |            ^^^
 26 |     pub fn new(
    |
   --> src/models/subsidiary.rs:26:12
note: associated function defined here
    |
    |         -------------- argument #2 of type `std::string::String` is missing
185 |         body.entity_id,
184 |         tenant_id,
    |                      ^^^^^^^^^^^^^^^
183 |     let subsidiary = Subsidiary::new(
    |
   --> src/api/handlers/subsidiary.rs:183:22
error[E0061]: this function takes 5 arguments but 4 arguments were supplied

    |                    ++++
178 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
178 | |         .extensions()
    |  _____________________-
177 |       let tenant_id = req
    |
   --> src/api/handlers/subsidiary.rs:178:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

    |
 14 +     let project = Project::new(req.tenant_id, req.entity_id, req.subsidiary_id, req.name.clone(), req.code.clone(), req.description.clone(), req.project_type.clone(), req.manager_id, req.created_by, /* chrono::DateTime<chrono::Utc> */, /* chrono::DateTime<chrono::Utc> */, /* uuid::Uuid */);
 24 -     );
 23 -         req.created_by,
 22 -         req.manager_id,
 21 -         req.project_type.clone(),
 20 -         req.description.clone(),
 19 -         req.code.clone(),
 18 -         req.name.clone(),
 17 -         req.subsidiary_id,
 16 -         req.entity_id,
 15 -         req.tenant_id,
 14 -     let project = Project::new(
    |
help: provide the arguments
    |         ----------------
105 |         created_by: Uuid,
    |         -----------------------
104 |         end_date: DateTime<Utc>,
    |         -------------------------
103 |         start_date: DateTime<Utc>,
...
    |            ^^^
 93 |     pub fn new(
    |
   --> src/models/project/core.rs:93:12
note: associated function defined here
    |
    | |_____- three arguments of type `chrono::DateTime<chrono::Utc>`, `chrono::DateTime<chrono::Utc>`, and `uuid::Uuid` are missing
 24 | |     );
 23 | |         req.created_by,
...   |
 17 | |         req.subsidiary_id,
 16 | |         req.entity_id,
 15 | |         req.tenant_id,
    |  ___________________^^^^^^^^^^^^-
 14 |       let project = Project::new(
    |
   --> src/api/handlers/project.rs:14:19
error[E0061]: this function takes 12 arguments but 9 arguments were supplied

    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
241 | pub trait ProjectExtension: Send + Sync {
    |
   --> src/models/project/core.rs:241:1
note: `ProjectExtension` defines an item `validate`, perhaps you need to implement it
    = help: items from traits can only be used if the trait is implemented and in scope
    |
    |          ^^^^^^^^ method not found in `actix_web::web::Json<ExecuteTaskRequest>`
 80 |     body.validate().map_err(|e| ApiError::ValidationError {
    |
   --> src/api/handlers/execution_handlers.rs:80:10
error[E0599]: no method named `validate` found for struct `actix_web::web::Json<ExecuteTaskRequest>` in the current scope

    |                    ++++
334 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
334 | |         .extensions()
    |  _____________________-
333 |       let tenant_id = req
    |
   --> src/api/handlers/entity.rs:334:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

    |                    ++++
270 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
270 | |         .extensions()
    |  _____________________-
269 |       let tenant_id = req
    |
   --> src/api/handlers/entity.rs:270:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

    |                    ++++
234 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
234 | |         .extensions()
    |  _____________________-
233 |       let tenant_id = req
    |
   --> src/api/handlers/entity.rs:234:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

    |                    ++++
204 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
204 | |         .extensions()
    |  _____________________-
203 |       let tenant_id = req
    |
   --> src/api/handlers/entity.rs:204:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

    |                    ++++
170 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
170 | |         .extensions()
    |  _____________________-
169 |       let tenant_id = req
    |
   --> src/api/handlers/entity.rs:170:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

   | ------------------------- method `list_by_tenant` not found for this struct
 8 | pub struct CostRepository {
   |
  ::: src/db/repositories/cost_repository.rs:8:1
   |
   |                     ^^^^^^^^^^^^^^ method not found in `CostRepository`
24 |     match cost_repo.list_by_tenant(&tenant_id).await {
   |
  --> src/api/handlers/costs.rs:24:21
error[E0599]: no method named `list_by_tenant` found for struct `CostRepository` in the current scope

   |                      ^^^^ method not found in `std::sync::Arc<Database>`
20 |     let db = data.db.lock().await;
   |
  --> src/api/handlers/costs.rs:20:22
error[E0599]: no method named `lock` found for struct `std::sync::Arc<Database>` in the current scope

   |                    ++++
15 |         .extensions_mut()
   |
help: there is a method `extensions_mut` with a similar name
   |
 1 + use actix_web::HttpMessage;
   |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
   = help: items from traits can only be used if the trait is in scope
   |
   |          ---------- the method is available for `HttpRequest` here
29 |       fn extensions(&self) -> Ref<'_, Extensions>;
   |
  ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
   |
   | |_________-^^^^^^^^^^
15 | |         .extensions()
   |  _____________________-
14 |       let tenant_id = req
   |
  --> src/api/handlers/costs.rs:15:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

    |
 81 +         .map_err(|e| ApiError::InternalError(format!("Failed to store session: {}", e)))?;
 81 -         .map_err(|e| ApiError::InternalServerError(format!("Failed to store session: {}", e)))?;
    |
help: there is a variant with a similar name
    |
    | ----------------- variant or associated item `InternalServerError` not found for this enum
121 | pub enum ApiError {
    |
   ::: src/api/response.rs:121:1
    |
    |                                ^^^^^^^^^^^^^^^^^^^ variant or associated item not found in `response::ApiError`
 81 |         .map_err(|e| ApiError::InternalServerError(format!("Failed to store session: {}", e)))?;
    |
   --> src/api/handlers/auth/refresh.rs:81:32
error[E0599]: no variant or associated item named `InternalServerError` found for enum `response::ApiError` in the current scope

   = note: available fields are: `db`, `auth_config`, `jwt_service`, `rate_limiter`, `usage_repo` ... and 7 others
   |
   |          ^^^^^^^^^^^^ unknown field
71 |         .session_repo
   |
  --> src/api/handlers/auth/refresh.rs:71:10
error[E0609]: no field `session_repo` on type `actix_web::web::Data<app_state_unified::AppState>`

    |
 66 +     .map_err(|e| ApiError::InternalError(format!("Failed to generate refresh token: {}", e)))?;
 66 -     .map_err(|e| ApiError::InternalServerError(format!("Failed to generate refresh token: {}", e)))?;
    |
help: there is a variant with a similar name
    |
    | ----------------- variant or associated item `InternalServerError` not found for this enum
121 | pub enum ApiError {
    |
   ::: src/api/response.rs:121:1
    |
    |                            ^^^^^^^^^^^^^^^^^^^ variant or associated item not found in `response::ApiError`
 66 |     .map_err(|e| ApiError::InternalServerError(format!("Failed to generate refresh token: {}", e)))?;
    |
   --> src/api/handlers/auth/refresh.rs:66:28
error[E0599]: no variant or associated item named `InternalServerError` found for enum `response::ApiError` in the current scope

   = note: available fields are: `db`, `auth_config`, `jwt_service`, `rate_limiter`, `usage_repo` ... and 7 others
   |
   |                ^^^^^^ unknown field
63 |         &state.config.jwt_secret,
   |
  --> src/api/handlers/auth/refresh.rs:63:16
error[E0609]: no field `config` on type `actix_web::web::Data<app_state_unified::AppState>`

    |
 56 +     .map_err(|e| ApiError::InternalError(format!("Failed to generate access token: {}", e)))?;
 56 -     .map_err(|e| ApiError::InternalServerError(format!("Failed to generate access token: {}", e)))?;
    |
help: there is a variant with a similar name
    |
    | ----------------- variant or associated item `InternalServerError` not found for this enum
121 | pub enum ApiError {
    |
   ::: src/api/response.rs:121:1
    |
    |                            ^^^^^^^^^^^^^^^^^^^ variant or associated item not found in `response::ApiError`
 56 |     .map_err(|e| ApiError::InternalServerError(format!("Failed to generate access token: {}", e)))?;
    |
   --> src/api/handlers/auth/refresh.rs:56:28
error[E0599]: no variant or associated item named `InternalServerError` found for enum `response::ApiError` in the current scope

   = note: available fields are: `db`, `auth_config`, `jwt_service`, `rate_limiter`, `usage_repo` ... and 7 others
   |
   |                ^^^^^^ unknown field
53 |         &state.config.jwt_secret,
   |
  --> src/api/handlers/auth/refresh.rs:53:16
error[E0609]: no field `config` on type `actix_web::web::Data<app_state_unified::AppState>`

    |     ------------ `response::ApiError::Unauthorized` defined here
127 |     Unauthorized,
    |
   ::: src/api/response.rs:127:5
    |
    |                      call expression requires function
    |                      |
    |                      ^^^^^^^^^^^^^^^^^^^^^^------------------------------
 45 |         .map_err(|_| ApiError::Unauthorized("User not found".to_string()))?;
    |
   --> src/api/handlers/auth/refresh.rs:45:22
error[E0618]: expected function, found `response::ApiError`

   |
42 +         .usage_repo
42 -         .user_repo
   |
help: a field with a similar name exists
   |
   |          ^^^^^^^^^ unknown field
42 |         .user_repo
   |
  --> src/api/handlers/auth/refresh.rs:42:10
error[E0609]: no field `user_repo` on type `actix_web::web::Data<app_state_unified::AppState>`

   |                       ^^^^ method not found in `std::sync::Arc<Database>`
40 |     let db = state.db.lock().await;
   |
  --> src/api/handlers/auth/refresh.rs:40:23
error[E0599]: no method named `lock` found for struct `std::sync::Arc<Database>` in the current scope

    |     ------------ `response::ApiError::Unauthorized` defined here
127 |     Unauthorized,
    |
   ::: src/api/response.rs:127:5
    |
    |                    call expression requires function
    |                    |
    |                    ^^^^^^^^^^^^^^^^^^^^^^----------------------------------
 36 |         return Err(ApiError::Unauthorized("Invalid token type".to_string()));
    |
   --> src/api/handlers/auth/refresh.rs:36:20
error[E0618]: expected function, found `response::ApiError`

    |     ------------ `response::ApiError::Unauthorized` defined here
127 |     Unauthorized,
    |
   ::: src/api/response.rs:127:5
    |
    |                      call expression requires function
    |                      |
    |                      ^^^^^^^^^^^^^^^^^^^^^^-------------------------------------
 32 |         .map_err(|_| ApiError::Unauthorized("Invalid refresh token".to_string()))?;
    |
   --> src/api/handlers/auth/refresh.rs:32:22
error[E0618]: expected function, found `response::ApiError`

   = note: available fields are: `db`, `auth_config`, `jwt_service`, `rate_limiter`, `usage_repo` ... and 7 others
   |
   |                                                          ^^^^^^ unknown field
31 |     let claims = validate_jwt(&req.refresh_token, &state.config.jwt_secret)
   |
  --> src/api/handlers/auth/refresh.rs:31:58
error[E0609]: no field `config` on type `actix_web::web::Data<app_state_unified::AppState>`

    |                    ++++
160 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
160 | |         .extensions()
    |  _____________________-
159 |       let tenant_id = req
    |
   --> src/api/handlers/audit/query.rs:160:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

    |                    ++++
135 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
135 | |         .extensions()
    |  _____________________-
134 |       let tenant_id = req
    |
   --> src/api/handlers/audit/query.rs:135:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

    |                    ++++
102 |         .extensions_mut()
    |
help: there is a method `extensions_mut` with a similar name
    |
  1 + use actix_web::HttpMessage;
    |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
    = help: items from traits can only be used if the trait is in scope
    |
    |          ---------- the method is available for `HttpRequest` here
 29 |       fn extensions(&self) -> Ref<'_, Extensions>;
    |
   ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
    |
    | |_________-^^^^^^^^^^
102 | |         .extensions()
    |  _____________________-
101 |       let tenant_id = req
    |
   --> src/api/handlers/audit/query.rs:102:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

   |                    ++++
78 |         .extensions_mut()
   |
help: there is a method `extensions_mut` with a similar name
   |
 1 + use actix_web::HttpMessage;
   |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
   = help: items from traits can only be used if the trait is in scope
   |
   |          ---------- the method is available for `HttpRequest` here
29 |       fn extensions(&self) -> Ref<'_, Extensions>;
   |
  ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
   |
   | |_________-^^^^^^^^^^
78 | |         .extensions()
   |  _____________________-
77 |       let tenant_id = req
   |
  --> src/api/handlers/audit/query.rs:78:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

   |                          +++++++++
53 |                 if event.resource.resource_type != *resource_type {
   |
help: one of the expressions' fields has a field of the same name
   |
   |                          ^^^^^^^^^^^^^ unknown field
53 |                 if event.resource_type != *resource_type {
   |
  --> src/api/handlers/audit/query.rs:53:26
error[E0609]: no field `resource_type` on type `AuditEvent`

   |
48 +                 if event.actor != *action {
48 -                 if event.action != *action {
   |
help: a field with a similar name exists
   |
   |                          ^^^^^^ unknown field
48 |                 if event.action != *action {
   |
  --> src/api/handlers/audit/query.rs:48:26
error[E0609]: no field `action` on type `AuditEvent`

   = note: available fields are: `id`, `timestamp`, `tenant_id`, `shard_key`, `actor` ... and 10 others
   |
   |                          ^^^^^^^ unknown field
43 |                 if event.user_id != *user_id {
   |
  --> src/api/handlers/audit/query.rs:43:26
error[E0609]: no field `user_id` on type `AuditEvent`

   |                      ^^^^ method not found in `std::sync::Arc<Database>`
26 |     let db = data.db.lock().await;
   |
  --> src/api/handlers/audit/query.rs:26:22
error[E0599]: no method named `lock` found for struct `std::sync::Arc<Database>` in the current scope

   |                    ++++
20 |         .extensions_mut()
   |
help: there is a method `extensions_mut` with a similar name
   |
 1 + use actix_web::HttpMessage;
   |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
   = help: items from traits can only be used if the trait is in scope
   |
   |          ---------- the method is available for `HttpRequest` here
29 |       fn extensions(&self) -> Ref<'_, Extensions>;
   |
  ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
   |
   | |_________-^^^^^^^^^^
20 | |         .extensions()
   |  _____________________-
19 |       let tenant_id = req
   |
  --> src/api/handlers/audit/query.rs:20:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

   |                    ++++
92 |         .extensions_mut()
   |
help: there is a method `extensions_mut` with a similar name
   |
 1 + use actix_web::HttpMessage;
   |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
   = help: items from traits can only be used if the trait is in scope
   |
   |          ---------- the method is available for `HttpRequest` here
29 |       fn extensions(&self) -> Ref<'_, Extensions>;
   |
  ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
   |
   | |_________-^^^^^^^^^^
92 | |         .extensions()
   |  _____________________-
91 |       let tenant_id = req
   |
  --> src/api/handlers/audit/compliance.rs:92:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

   |                    ++++
58 |         .extensions_mut()
   |
help: there is a method `extensions_mut` with a similar name
   |
 1 + use actix_web::HttpMessage;
   |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
   = help: items from traits can only be used if the trait is in scope
   |
   |          ---------- the method is available for `HttpRequest` here
29 |       fn extensions(&self) -> Ref<'_, Extensions>;
   |
  ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
   |
   | |_________-^^^^^^^^^^
58 | |         .extensions()
   |  _____________________-
57 |       let tenant_id = req
   |
  --> src/api/handlers/audit/compliance.rs:58:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

   |                    ++++
21 |         .extensions_mut()
   |
help: there is a method `extensions_mut` with a similar name
   |
 1 + use actix_web::HttpMessage;
   |
help: trait `HttpMessage` which provides `extensions` is implemented but not in scope; perhaps you want to import it
   = help: items from traits can only be used if the trait is in scope
   |
   |          ---------- the method is available for `HttpRequest` here
29 |       fn extensions(&self) -> Ref<'_, Extensions>;
   |
  ::: /usr/local/cargo/registry/src/index.crates.io-1949cf8c6b5b557f/actix-http-3.11.1/src/http_message.rs:29:8
   |
   | |_________-^^^^^^^^^^
21 | |         .extensions()
   |  _____________________-
20 |       let tenant_id = req
   |
  --> src/api/handlers/audit/compliance.rs:21:10
error[E0599]: no method named `extensions` found for struct `HttpRequest` in the current scope

    |   ----------------------------- method `list_events` not found for this struct
 13 |   pub struct AuditLogRepository {
    |
   ::: src/db/repositories/audit_log_repository.rs:13:1
    |
    |
    | |_________|
    | |         -^^^^^^^^^^^ method not found in `AuditLogRepository`
237 | |         .list_events(
    |  __________________-
236 |       let events = audit_repo
    |
   --> src/api/handlers/audit/basic.rs:237:10
error[E0599]: no method named `list_events` found for struct `AuditLogRepository` in the current scope

    |                                                        ++++++++++++++++++
229 |     let audit_repo = AuditLogRepository::new(db.clone(), /* uuid::Uuid */);
    |
help: provide the argument
    |            ^^^                    ---------------
 19 |     pub fn new(db: Arc<Database>, tenant_id: Uuid) -> Self {
    |
   --> src/db/repositories/audit_log_repository.rs:19:12
note: associated function defined here
    |
    |                      ^^^^^^^^^^^^^^^^^^^^^^^------------ argument #2 of type `uuid::Uuid` is missing
229 |     let audit_repo = AuditLogRepository::new(db.clone());
    |
   --> src/api/handlers/audit/basic.rs:229:22
error[E0061]: this function takes 2 arguments but 1 argument was supplied

    |                      ^^^^ method not found in `std::sync::Arc<Database>`
228 |     let db = data.db.lock().await;
    |
   --> src/api/handlers/audit/basic.rs:228:22
error[E0599]: no method named `lock` found for struct `std::sync::Arc<Database>` in the current scope

    | ----------------------------- method `get_event` not found for this struct
 13 | pub struct AuditLogRepository {
    |
   ::: src/db/repositories/audit_log_repository.rs:13:1
    |
    |                      ^^^^^^^^^ method not found in `AuditLogRepository`
196 |     match audit_repo.get_event(&tenant_id, &event_id).await {
    |
   --> src/api/handlers/audit/basic.rs:196:22
error[E0599]: no method named `get_event` found for struct `AuditLogRepository` in the current scope

    |                                                        ++++++++++++++++++
193 |     let audit_repo = AuditLogRepository::new(db.clone(), /* uuid::Uuid */);
    |
help: provide the argument
    |            ^^^                    ---------------
 19 |     pub fn new(db: Arc<Database>, tenant_id: Uuid) -> Self {
    |
   --> src/db/repositories/audit_log_repository.rs:19:12
note: associated function defined here
    |
    |                      ^^^^^^^^^^^^^^^^^^^^^^^------------ argument #2 of type `uuid::Uuid` is missing
193 |     let audit_repo = AuditLogRepository::new(db.clone());
    |
   --> src/api/handlers/audit/basic.rs:193:22
error[E0061]: this function takes 2 arguments but 1 argument was supplied

    |                      ^^^^ method not found in `std::sync::Arc<Database>`
192 |     let db = data.db.lock().await;
    |
   --> src/api/handlers/audit/basic.rs:192:22
error[E0599]: no method named `lock` found for struct `std::sync::Arc<Database>` in the current scope

    |   ----------------------------- method `list_events` not found for this struct
 13 |   pub struct AuditLogRepository {
    |
   ::: src/db/repositories/audit_log_repository.rs:13:1
    |
    |
    | |_________|
    | |         -^^^^^^^^^^^ method not found in `AuditLogRepository`
150 | |         .list_events(
    |  __________________-
149 |       let events = audit_repo
    |
   --> src/api/handlers/audit/basic.rs:150:10
error[E0599]: no method named `list_events` found for struct `AuditLogRepository` in the current scope

    |                                                        ++++++++++++++++++
127 |     let audit_repo = AuditLogRepository::new(db.clone(), /* uuid::Uuid */);
    |
help: provide the argument
    |            ^^^                    ---------------
 19 |     pub fn new(db: Arc<Database>, tenant_id: Uuid) -> Self {
    |
   --> src/db/repositories/audit_log_repository.rs:19:12
note: associated function defined here
    |
    |                      ^^^^^^^^^^^^^^^^^^^^^^^------------ argument #2 of type `uuid::Uuid` is missing
127 |     let audit_repo = AuditLogRepository::new(db.clone());
    |
   --> src/api/handlers/audit/basic.rs:127:22
error[E0061]: this function takes 2 arguments but 1 argument was supplied

    |                      ^^^^ method not found in `std::sync::Arc<Database>`
126 |     let db = data.db.lock().await;
    |
   --> src/api/handlers/audit/basic.rs:126:22
error[E0599]: no method named `lock` found for struct `std::sync::Arc<Database>` in the current scope

    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
241 | pub trait ProjectExtension: Send + Sync {
    |
   --> src/models/project/core.rs:241:1
note: `ProjectExtension` defines an item `validate`, perhaps you need to implement it
    = help: items from traits can only be used if the trait is implemented and in scope
    |
    |          ^^^^^^^^ method not found in `actix_web::web::Json<agent_models::CreateTeamRequest>`
277 |     body.validate().map_err(|e| ApiError::ValidationError {
    |
   --> src/api/handlers/agent_handlers.rs:277:10
error[E0599]: no method named `validate` found for struct `actix_web::web::Json<agent_models::CreateTeamRequest>` in the current scope

    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
241 | pub trait ProjectExtension: Send + Sync {
    |
   --> src/models/project/core.rs:241:1
note: `ProjectExtension` defines an item `validate`, perhaps you need to implement it
    = help: items from traits can only be used if the trait is implemented and in scope
    |
    |          ^^^^^^^^ method not found in `actix_web::web::Json<agent_models::UpdateAgentRequest>`
111 |     body.validate().map_err(|e| ApiError::ValidationError {
    |
   --> src/api/handlers/agent_handlers.rs:111:10
error[E0599]: no method named `validate` found for struct `actix_web::web::Json<agent_models::UpdateAgentRequest>` in the current scope

    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
241 | pub trait ProjectExtension: Send + Sync {
    |
   --> src/models/project/core.rs:241:1
note: `ProjectExtension` defines an item `validate`, perhaps you need to implement it
    = help: items from traits can only be used if the trait is implemented and in scope
    |
    |          ^^^^^^^^ method not found in `actix_web::web::Json<agent_models::CreateAgentRequest>`
 17 |     body.validate().map_err(|e| ApiError::ValidationError {
    |
   --> src/api/handlers/agent_handlers.rs:17:10
error[E0599]: no method named `validate` found for struct `actix_web::web::Json<agent_models::CreateAgentRequest>` in the current scope

    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
241 | pub trait ProjectExtension: Send + Sync {
    |
   --> src/models/project/core.rs:241:1
note: `ProjectExtension` defines an item `validate`, perhaps you need to implement it
    = help: items from traits can only be used if the trait is implemented and in scope
    |
    |                          ^^^^^^^^ method not found in `actix_web::web::Json<auth_types::UpdateProfileRequest>`
 72 |     if let Err(e) = body.validate() {
    |
   --> src/api/auth/handlers/profile.rs:72:26
error[E0599]: no method named `validate` found for struct `actix_web::web::Json<auth_types::UpdateProfileRequest>` in the current scope

    |                                  ^^^^^^^^^^ unknown field
149 |         expires_in: access_token.expires_in,
    |
   --> src/api/auth/handlers/login.rs:149:34
error[E0609]: no field `expires_in` on type `std::string::String`

    |                                    ^^^^^ unknown field
147 |         access_token: access_token.token,
    |
   --> src/api/auth/handlers/login.rs:147:36
error[E0609]: no field `token` on type `std::string::String`

    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
241 | pub trait ProjectExtension: Send + Sync {
    |
   --> src/models/project/core.rs:241:1
note: `ProjectExtension` defines an item `validate`, perhaps you need to implement it
    = help: items from traits can only be used if the trait is implemented and in scope
    |
    |                          ^^^^^^^^ method not found in `actix_web::web::Json<auth_types::LoginRequest>`
 19 |     if let Err(e) = body.validate() {
    |
   --> src/api/auth/handlers/login.rs:19:26
error[E0599]: no method named `validate` found for struct `actix_web::web::Json<auth_types::LoginRequest>` in the current scope

    |                                  ^^^^^^^^^^ unknown field
139 |         expires_in: access_token.expires_in,
    |
   --> src/api/auth/handlers/register.rs:139:34
error[E0609]: no field `expires_in` on type `std::string::String`

    |                                    ^^^^^ unknown field
137 |         access_token: access_token.token,
    |
   --> src/api/auth/handlers/register.rs:137:36
error[E0609]: no field `token` on type `std::string::String`

    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
241 | pub trait ProjectExtension: Send + Sync {
    |
   --> src/models/project/core.rs:241:1
note: `ProjectExtension` defines an item `validate`, perhaps you need to implement it
    = help: items from traits can only be used if the trait is implemented and in scope
    |
    |                          ^^^^^^^^ method not found in `actix_web::web::Json<auth_types::RegisterRequest>`
 21 |     if let Err(e) = body.validate() {
    |
   --> src/api/auth/handlers/register.rs:21:26
error[E0599]: no method named `validate` found for struct `actix_web::web::Json<auth_types::RegisterRequest>` in the current scope

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
119 |     pub async fn get_provider(&self, provider_type: Provider) -> Option<Arc<dyn AIProvider>> {
    |
   --> src/ai/router/mod.rs:119:5
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
121 |         providers.get(&provider_type).cloned()
    |
   --> src/ai/router/mod.rs:121:9
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
121 |         providers.get(&provider_type).cloned()
    |
   --> src/ai/router/mod.rs:121:9
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                                               ^^^^^ `ai::AIProvider` is not dyn compatible
120 |         let providers = self.providers.read().await;
    |
   --> src/ai/router/mod.rs:120:47
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                         ^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
120 |         let providers = self.providers.read().await;
    |
   --> src/ai/router/mod.rs:120:25
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    |                                                       ++++++++++++
111 |                 status.map(|s| s.available).map_err(|e: /* Type */| anyhow!(e)),
    |
help: consider giving this closure parameter an explicit type
    |
    |                                                      ^  ---------- type must be known at this point
111 |                 status.map(|s| s.available).map_err(|e| anyhow!(e)),
    |
   --> src/ai/router/mod.rs:111:54
error[E0282]: type annotations needed

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
108 |             let status = provider.check_availability().await;
    |
   --> src/ai/router/mod.rs:108:26
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                                          ^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
107 |         for (provider_type, provider) in providers.iter() {
    |
   --> src/ai/router/mod.rs:107:42
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                                               ^^^^^ `ai::AIProvider` is not dyn compatible
105 |         let providers = self.providers.read().await;
    |
   --> src/ai/router/mod.rs:105:47
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                         ^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
105 |         let providers = self.providers.read().await;
    |
   --> src/ai/router/mod.rs:105:25
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
 93 |         let response = provider.execute(&request).await?;
    |
   --> src/ai/router/mod.rs:93:24
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    | |___________________________________________________________________________________^ `ai::AIProvider` is not dyn compatible
 91 | |             .ok_or_else(|| anyhow!("Provider {:?} not registered", provider_type))?;
 90 | |             .get(&provider_type)
    |  ________________________^
 89 |           let provider = providers
    |
   --> src/ai/router/mod.rs:89:24
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    | |__________________________________________________________________________________^ `ai::AIProvider` is not dyn compatible
 91 | |             .ok_or_else(|| anyhow!("Provider {:?} not registered", provider_type))?;
 90 | |             .get(&provider_type)
    |  ________________________^
 89 |           let provider = providers
    |
   --> src/ai/router/mod.rs:89:24
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    | |________________________________^ `ai::AIProvider` is not dyn compatible
 90 | |             .get(&provider_type)
    |  ________________________^
 89 |           let provider = providers
    |
   --> src/ai/router/mod.rs:89:24
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                                               ^^^^^ `ai::AIProvider` is not dyn compatible
 88 |         let providers = self.providers.read().await;
    |
   --> src/ai/router/mod.rs:88:47
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                         ^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
 88 |         let providers = self.providers.read().await;
    |
   --> src/ai/router/mod.rs:88:25
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    | |_________________________________________________________________^ `ai::AIProvider` is not dyn compatible
 71 | |                 .execute_with_model(&request, &selected.model.id)
 70 | /             provider
    |
   --> src/ai/router/mod.rs:70:13
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
 68 |             provider.execute_with_model(&request, &model_id).await?
    |
   --> src/ai/router/mod.rs:68:13
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    | |_____________________________________________________________________________________________^ `ai::AIProvider` is not dyn compatible
 64 | |             .ok_or_else(|| anyhow!("Provider {:?} not registered", selected.model.provider))?;
 63 | |             .get(&selected.model.provider)
    |  ________________________^
 62 |           let provider = providers
    |
   --> src/ai/router/mod.rs:62:24
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    | |____________________________________________________________________________________________^ `ai::AIProvider` is not dyn compatible
 64 | |             .ok_or_else(|| anyhow!("Provider {:?} not registered", selected.model.provider))?;
 63 | |             .get(&selected.model.provider)
    |  ________________________^
 62 |           let provider = providers
    |
   --> src/ai/router/mod.rs:62:24
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    | |__________________________________________^ `ai::AIProvider` is not dyn compatible
 63 | |             .get(&selected.model.provider)
    |  ________________________^
 62 |           let provider = providers
    |
   --> src/ai/router/mod.rs:62:24
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                                               ^^^^^ `ai::AIProvider` is not dyn compatible
 61 |         let providers = self.providers.read().await;
    |
   --> src/ai/router/mod.rs:61:47
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                         ^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
 61 |         let providers = self.providers.read().await;
    |
   --> src/ai/router/mod.rs:61:25
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
 46 |         self.providers.write().await.insert(provider_type, provider);
    |
   --> src/ai/router/mod.rs:46:9
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                                ^^^^^ `ai::AIProvider` is not dyn compatible
 46 |         self.providers.write().await.insert(provider_type, provider);
    |
   --> src/ai/router/mod.rs:46:32
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |         ^^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
 46 |         self.providers.write().await.insert(provider_type, provider);
    |
   --> src/ai/router/mod.rs:46:9
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
 45 |         let provider_type = provider.provider_type();
    |
   --> src/ai/router/mod.rs:45:29
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

  |     ^^^^^^^^^^^
2 | use chrono::Utc;
  |
 --> src/services/system_monitor/alerts.rs:2:5
warning: unused import: `chrono::Utc`

  |              ^^^^^^
1 | use anyhow::{anyhow, Result};
  |
 --> src/services/event_capture/processor.rs:1:14
warning: unused import: `anyhow`

  |     ^^^^^^^^^^^^^^
1 | use anyhow::Result;
  |
 --> src/services/event_capture/analytics.rs:1:5
warning: unused import: `anyhow::Result`

   |                               ^^^^^^^^^^^^^^
12 |     audit_event::{AuditEvent, AuditEventType},
   |
  --> src/services/audit_service.rs:12:31
warning: unused import: `AuditEventType`

  = note: `#[warn(unused_doc_comments)]` on by default
  = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion
  |
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
6 | /// Thread-local storage for tenant context
  |
 --> src/security/tenant_isolation.rs:6:1
warning: unused doc comment

  = note: `#[warn(unexpected_cfgs)]` on by default
  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
  = help: consider adding `integration-examples` as a feature in `Cargo.toml`
  = note: no expected values for `feature`
  |
  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove the condition
6 | #[cfg(feature = "integration-examples")]
  |
 --> src/security/mod.rs:6:7
warning: unexpected `cfg` condition value: `integration-examples`

  |              ^^^^^^^^  ^^^
1 | use chrono::{DateTime, Utc};
  |
 --> src/models/project/extensions/pmi.rs:1:14
warning: unused imports: `DateTime` and `Utc`

  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
4 | use std::collections::HashMap;
  |
 --> src/models/project/core.rs:4:5
warning: unused import: `std::collections::HashMap`

  |              ^^^^^^^^
4 | use chrono::{DateTime, Utc, Duration};
  |
 --> src/minimal/auth.rs:4:14
warning: unused import: `DateTime`

  |                                                   ^^^^^^
1 | use actix_web::{error, HttpRequest, HttpResponse, Result};
  |
 --> src/api/middleware/json_error_handler.rs:1:51
warning: unused import: `Result`

  |                           ^^^^^^^^
8 | use crate::models::{User, UserRole};
  |
 --> src/api/handlers/user.rs:8:27
warning: unused import: `UserRole`

  |                     ^^^^  ^^^^^^^  ^^^^  ^^^^^^  ^^^^^^^^^^
7 | use crate::models::{User, Project, Task, Entity, Subsidiary};
  |
 --> src/api/handlers/test.rs:7:21
warning: unused imports: `Entity`, `Project`, `Subsidiary`, `Task`, and `User`

   |                                                       ^^^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^
11 | use crate::models::{ProjectMember, ProjectRole, Task, TaskPriority, TaskStatus, TaskType};
   |
  --> src/api/handlers/task.rs:11:55
warning: unused imports: `TaskPriority`, `TaskStatus`, and `TaskType`

  |                                 ^^^^^^^^^^^^^^^^
8 | use crate::models::{Subsidiary, SubsidiaryStatus};
  |
 --> src/api/handlers/subsidiary.rs:8:33
warning: unused import: `SubsidiaryStatus`

  |                              ^^^^^^^^^^^^^  ^^^^^^^^^^^
7 | use crate::models::{Project, ProjectStatus, ProjectType};
  |
 --> src/api/handlers/project.rs:7:30
warning: unused imports: `ProjectStatus` and `ProjectType`

  |     ^^^^^^^^^^^^^^^^^^^^
6 | use crate::api::ApiError;
  |
 --> src/api/handlers/audit/basic.rs:6:5
warning: unused import: `crate::api::ApiError`

  = note: `#[warn(unused_imports)]` on by default
  |
  |                           ^^^^^^^^
6 | use crate::models::{User, UserRole};
  |
 --> src/api/auth/auth_types.rs:6:27
warning: unused import: `UserRole`

   |
85 +         severity: SecuritySeverity,
85 -         severity: super::types::SecuritySeverity,
   |
help: if you import `SecuritySeverity`, refer to it directly
   |
 1 + use crate::models::audit_event::SecuritySeverity;
   |
help: consider importing this enum
   |
   |                                 ^^^^^^^^^^^^^^^^ not found in `super::types`
85 |         severity: super::types::SecuritySeverity,
   |
  --> src/services/event_capture/core.rs:85:33
error[E0412]: cannot find type `SecuritySeverity` in module `super::types`

   |
 1 + use actix_web::mime;
   |
help: consider importing this crate
   = help: if you wanted to use a crate named `mime`, use `cargo add mime` to add it to your `Cargo.toml`
   |
   |                                      ^^^^ use of unresolved module or unlinked crate `mime`
49 |                 && mime.subtype() == mime::JSON
   |
  --> src/api/middleware/json_error_handler.rs:49:38
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `mime`

   |
 1 + use actix_web::mime;
   |
help: consider importing this crate
   = help: if you wanted to use a crate named `mime`, use `cargo add mime` to add it to your `Cargo.toml`
   |
   |                             ^^^^ use of unresolved module or unlinked crate `mime`
48 |             mime.type_() == mime::APPLICATION
   |
  --> src/api/middleware/json_error_handler.rs:48:29
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `mime`

    |
367 +     body: web::Json<UpdateProfileRequest>,
367 -     body: web::Json<crate::api::dto::UpdateProfileRequest>,
    |
help: if you import `UpdateProfileRequest`, refer to it directly
    |
  1 + use crate::api::dto::auth::UpdateProfileRequest;
    |
  1 + use crate::api::auth::UpdateProfileRequest;
    |
help: consider importing one of these structs
    |
367 +     body: web::Json<crate::api::dto::UpdateProjectRequest>,
367 -     body: web::Json<crate::api::dto::UpdateProfileRequest>,
    |
help: a struct with a similar name exists
    |
    | ------------------------------- similarly named struct `UpdateProjectRequest` defined here
 20 | pub struct UpdateProjectRequest {
    |
   ::: src/api/dto/project.rs:20:1
    |
    |                                      ^^^^^^^^^^^^^^^^^^^^
367 |     body: web::Json<crate::api::dto::UpdateProfileRequest>,
    |
   --> src/api/handlers/user.rs:367:38
error[E0412]: cannot find type `UpdateProfileRequest` in module `crate::api::dto`

    |
328 +             let profile = UserProfile {
328 -             let profile = crate::api::dto::UserProfile {
    |
help: if you import `UserProfile`, refer to it directly
    |
  1 + use crate::api::dto::auth::UserProfile;
    |
  1 + use crate::api::auth::UserProfile;
    |
help: consider importing one of these structs
    |
    |                                            ^^^^^^^^^^^ not found in `crate::api::dto`
328 |             let profile = crate::api::dto::UserProfile {
    |
   --> src/api/handlers/user.rs:328:44
error[E0422]: cannot find struct, variant or union type `UserProfile` in module `crate::api::dto`

    |
267 +     body: web::Json<UpdateProfileRequest>,
267 -     body: web::Json<crate::api::dto::UpdateProfileRequest>,
    |
help: if you import `UpdateProfileRequest`, refer to it directly
    |
  1 + use crate::api::dto::auth::UpdateProfileRequest;
    |
  1 + use crate::api::auth::UpdateProfileRequest;
    |
help: consider importing one of these structs
    |
267 +     body: web::Json<crate::api::dto::UpdateProjectRequest>,
267 -     body: web::Json<crate::api::dto::UpdateProfileRequest>,
    |
help: a struct with a similar name exists
    |
    | ------------------------------- similarly named struct `UpdateProjectRequest` defined here
 20 | pub struct UpdateProjectRequest {
    |
   ::: src/api/dto/project.rs:20:1
    |
    |                                      ^^^^^^^^^^^^^^^^^^^^
267 |     body: web::Json<crate::api::dto::UpdateProfileRequest>,
    |
   --> src/api/handlers/user.rs:267:38
error[E0412]: cannot find type `UpdateProfileRequest` in module `crate::api::dto`

    |
231 +             let profile = UserProfile {
231 -             let profile = crate::api::dto::UserProfile {
    |
help: if you import `UserProfile`, refer to it directly
    |
  1 + use crate::api::dto::auth::UserProfile;
    |
  1 + use crate::api::auth::UserProfile;
    |
help: consider importing one of these structs
    |
    |                                            ^^^^^^^^^^^ not found in `crate::api::dto`
231 |             let profile = crate::api::dto::UserProfile {
    |
   --> src/api/handlers/user.rs:231:44
error[E0422]: cannot find struct, variant or union type `UserProfile` in module `crate::api::dto`

   |                        ^^^^^^^^^^^^^^^^^ not found in `crate::auth`
26 |     auth: crate::auth::AuthenticatedUser,
   |
  --> src/api/handlers/session.rs:26:24
error[E0412]: cannot find type `AuthenticatedUser` in module `crate::auth`

    |                                                ---- variable not in all patterns
180 |                 AuditEventType::Authentication(auth) if matches!(auth.action, AuthAction::LoginFailed { .. })
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `auth`
179 |                 AuditEventType::SecurityEvent(_) |
    |
   --> src/services/compliance_checks/controls/soc2.rs:179:17
error[E0408]: variable `auth` is not bound in all patterns

   = help: if you wanted to use a crate named `lru`, use `cargo add lru` to add it to your `Cargo.toml`
   |
   |                                                    ^^^ use of unresolved module or unlinked crate `lru`
33 |             redaction_cache: std::sync::Mutex::new(lru::LruCache::new(
   |
  --> src/memory/privacy.rs:33:52
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `lru`

    = help: if you wanted to use a crate named `regex`, use `cargo add regex` to add it to your `Cargo.toml`
    |
    |                                 ^^^^^ use of unresolved module or unlinked crate `regex`
187 |                 if let Ok(re) = regex::Regex::new(&format!("^{}$", pattern)) {
    |
   --> src/memory/capture.rs:187:33
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `regex`

    = help: if you wanted to use a crate named `regex`, use `cargo add regex` to add it to your `Cargo.toml`
    |
    |                             ^^^^^ use of unresolved module or unlinked crate `regex`
173 |             if let Ok(re) = regex::Regex::new(pattern) {
    |
   --> src/memory/capture.rs:173:29
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `regex`

    = help: if you wanted to use a crate named `regex`, use `cargo add regex` to add it to your `Cargo.toml`
    |
    |                             ^^^^^ use of unresolved module or unlinked crate `regex`
160 |             if let Ok(re) = regex::Regex::new(pattern) {
    |
   --> src/memory/capture.rs:160:29
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `regex`

    = help: if you wanted to use a crate named `dashmap`, use `cargo add dashmap` to add it to your `Cargo.toml`
    |
    |                 ^^^^^^^ use of unresolved module or unlinked crate `dashmap`
165 |     ) -> Option<dashmap::mapref::one::Ref<String, TerminalSession>> {
    |
   --> src/gateway/terminal_bridge/bridge.rs:165:17
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `dashmap`

    |       ^^^^^^^^
125 |     #[validate(range(min = 1, max = 100))]
    |
   --> src/api/validation.rs:125:7
error: cannot find attribute `validate` in this scope

    |       ^^^^^^^^
122 |     #[validate(range(min = 1, max = 100))]
    |
   --> src/api/validation.rs:122:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
56 |     #[validate(custom = "validate_task_type")]
   |
  --> src/api/schemas.rs:56:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
46 |     #[validate(range(
   |
  --> src/api/schemas.rs:46:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
43 |     #[validate(custom = "validate_priority")]
   |
  --> src/api/schemas.rs:43:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
40 |     #[validate(length(max = 1000, message = "Description cannot exceed 1000 characters"))]
   |
  --> src/api/schemas.rs:40:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
37 |     #[validate(length(min = 1, max = 200, message = "Title must be 1-200 characters"))]
   |
  --> src/api/schemas.rs:37:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
28 |     #[validate(custom = "validate_role")]
   |
  --> src/api/schemas.rs:28:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
25 |     #[validate(length(min = 1, max = 100, message = "Name must be 1-100 characters"))]
   |
  --> src/api/schemas.rs:25:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
19 |     #[validate(length(min = 8, message = "Password must be at least 8 characters"))]
   |
  --> src/api/schemas.rs:19:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
14 |     #[validate(custom = "validate_role")]
   |
  --> src/api/schemas.rs:14:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
11 |     #[validate(length(min = 1, max = 100, message = "Name must be 1-100 characters"))]
   |
  --> src/api/schemas.rs:11:7
error: cannot find attribute `validate` in this scope

  |       ^^^^^^^^
8 |     #[validate(email(message = "Invalid email format"))]
  |
 --> src/api/schemas.rs:8:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
14 |     #[validate(length(min = 1, max = 10000))]
   |
  --> src/api/handlers/execution_handlers.rs:14:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
57 |     #[validate(length(min = 8, max = 128))]
   |
  --> src/api/auth/auth_types.rs:57:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
49 |     #[validate(email)]
   |
  --> src/api/auth/auth_types.rs:49:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
41 |     #[validate(length(min = 2, max = 50))]
   |
  --> src/api/auth/auth_types.rs:41:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
39 |     #[validate(length(min = 2, max = 50))]
   |
  --> src/api/auth/auth_types.rs:39:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
25 |     #[validate(email(message = "Invalid email address"))]
   |
  --> src/api/auth/auth_types.rs:25:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
17 |     #[validate(length(min = 2, max = 50, message = "Last name must be 2-50 characters"))]
   |
  --> src/api/auth/auth_types.rs:17:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
15 |     #[validate(length(min = 2, max = 50, message = "First name must be 2-50 characters"))]
   |
  --> src/api/auth/auth_types.rs:15:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
13 |     #[validate(length(min = 8, max = 128, message = "Password must be 8-128 characters"))]
   |
  --> src/api/auth/auth_types.rs:13:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
11 |     #[validate(email(message = "Invalid email address"))]
   |
  --> src/api/auth/auth_types.rs:11:7
error: cannot find attribute `validate` in this scope

    |       ^^^^^^^^
101 |     #[validate(length(max = 1000))]
    |
   --> src/api/agent_models.rs:101:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
99 |     #[validate(length(min = 1, max = 255))]
   |
  --> src/api/agent_models.rs:99:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
76 |     #[validate(length(min = 1, max = 255))]
   |
  --> src/api/agent_models.rs:76:7
error: cannot find attribute `validate` in this scope

   |       ^^^^^^^^
13 |     #[validate(length(min = 1, max = 255))]
   |
  --> src/api/agent_models.rs:13:7
error: cannot find attribute `validate` in this scope

   |                 ^^^^^^^ use of unresolved module or unlinked crate `tracing`
53 |                 tracing::error!("Failed to update metrics: {}", e);
   |
  --> src/services/system_monitor/metrics.rs:53:17
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tracing`

    |   ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
221 | #[async_trait::async_trait]
    |
   --> src/services/memory_service.rs:221:3
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `async_trait`

    |                       ^^^ use of unresolved module or unlinked crate `log`
193 | ...                   log::error!("Failed to store knowledge: {}", e);
    |
   --> src/services/memory_service.rs:193:29
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

    |                 ^^^ use of unresolved module or unlinked crate `log`
176 |                 log::error!("Failed to update context: {}", e);
    |
   --> src/services/memory_service.rs:176:17
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

    |                 ^^^ use of unresolved module or unlinked crate `log`
171 |                 log::error!("Failed to store event: {}", e);
    |
   --> src/services/memory_service.rs:171:17
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

   |                     ^^^^^^^ use of unresolved module or unlinked crate `tracing`
29 |                     tracing::error!("Failed to log file event to audit: {}", e);
   |
  --> src/services/file_monitor/audit.rs:29:21
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tracing`

   |             ^^^^^^^ use of unresolved module or unlinked crate `tracing`
25 |             tracing::error!("Failed to process event: {}", e);
   |
  --> src/services/event_capture/processor.rs:25:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tracing`

    |                     ^^^^^^^ use of unresolved module or unlinked crate `tracing`
104 |                     tracing::info!("Cleaned up {} expired sessions", removed);
    |
   --> src/security/mod.rs:104:21
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tracing`

    |             ^^^^^^^ use of unresolved module or unlinked crate `tracing`
171 |             tracing::warn!(
    |
   --> src/security/session_security.rs:171:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tracing`

   |             ^^^^^^^ use of unresolved module or unlinked crate `tracing`
75 |             tracing::debug!("TenantExtractor: Set (user_id, tenant_id) tuple");
   |
  --> src/middleware/tenant_extractor.rs:75:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tracing`

   |                     ^^^^^^^ use of unresolved module or unlinked crate `tracing`
67 |                     tracing::debug!("TenantExtractor: Found user_id = {}", user_id);
   |
  --> src/middleware/tenant_extractor.rs:67:21
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tracing`

   |                     ^^^^^^^ use of unresolved module or unlinked crate `tracing`
57 |                     tracing::debug!("TenantExtractor: Set tenant_id = {}", tenant_id);
   |
  --> src/middleware/tenant_extractor.rs:57:21
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tracing`

    |                       ^^^^^^^ use of unresolved module or unlinked crate `tracing`
401 | ...                   tracing::error!("Failed to write audit log: {}", e);
    |
   --> src/middleware/audit_middleware.rs:401:29
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tracing`

    |                       ^^^^^^^ use of unresolved module or unlinked crate `tracing`
397 | ...                   tracing::debug!("Audit log written successfully");
    |
   --> src/middleware/audit_middleware.rs:397:29
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tracing`

    |                 ^^^^^^^ use of unresolved module or unlinked crate `tracing`
352 |                 tracing::info!(
    |
   --> src/middleware/audit_middleware.rs:352:17
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tracing`

    |             ^^^^^^^ use of unresolved module or unlinked crate `tracing`
317 |             tracing::debug!(
    |
   --> src/middleware/audit_middleware.rs:317:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tracing`

    |   ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
212 | #[async_trait::async_trait]
    |
   --> src/memory/mod.rs:212:3
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `async_trait`

    |             ^^^ use of unresolved module or unlinked crate `log`
432 |             log::error!("Failed to get user: {}", e);
    |
   --> src/api/handlers/user.rs:432:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

    |             ^^^ use of unresolved module or unlinked crate `log`
394 |             log::error!("Failed to list users: {}", e);
    |
   --> src/api/handlers/user.rs:394:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

    |             ^^^ use of unresolved module or unlinked crate `log`
345 |             log::error!("Failed to update user: {}", e);
    |
   --> src/api/handlers/user.rs:345:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

    |             ^^^ use of unresolved module or unlinked crate `log`
304 |             log::error!("Database error fetching user: {}", e);
    |
   --> src/api/handlers/user.rs:304:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

    |             ^^^ use of unresolved module or unlinked crate `log`
253 |             log::error!("Database error fetching user: {}", e);
    |
   --> src/api/handlers/user.rs:253:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

   |             ^^^ use of unresolved module or unlinked crate `log`
31 |             log::error!("Failed to list usage: {}", e);
   |
  --> src/api/handlers/usage.rs:31:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

   |             ^^^ use of unresolved module or unlinked crate `log`
31 |             log::error!("Failed to list costs: {}", e);
   |
  --> src/api/handlers/costs.rs:31:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

   |         ^^^ use of unresolved module or unlinked crate `log`
37 |         log::error!("Failed to revoke sessions for user {}: {}", claims.user_id, e);
   |
  --> src/api/handlers/auth/logout.rs:37:9
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

    |             ^^^ use of unresolved module or unlinked crate `log`
249 |             log::error!("Failed to get audit stats: {:?}", e);
    |
   --> src/api/handlers/audit/basic.rs:249:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

    |             ^^^ use of unresolved module or unlinked crate `log`
208 |             log::error!("Failed to get audit event: {:?}", e);
    |
   --> src/api/handlers/audit/basic.rs:208:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

    |             ^^^ use of unresolved module or unlinked crate `log`
162 |             log::error!("Failed to list audit events: {:?}", e);
    |
   --> src/api/handlers/audit/basic.rs:162:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

    |             ^^^ use of unresolved module or unlinked crate `log`
153 |             log::error!("Failed to update user: {}", e);
    |
   --> src/api/auth/handlers/profile.rs:153:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

    |             ^^^ use of unresolved module or unlinked crate `log`
128 |             log::error!("Database error fetching user: {}", e);
    |
   --> src/api/auth/handlers/profile.rs:128:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

   |             ^^^ use of unresolved module or unlinked crate `log`
56 |             log::error!("Database error fetching user: {}", e);
   |
  --> src/api/auth/handlers/profile.rs:56:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

   |         ^^^ use of unresolved module or unlinked crate `log`
51 |         log::error!("Failed to revoke sessions: {}", e);
   |
  --> src/api/auth/handlers/logout.rs:51:9
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

    |         ^^^ use of unresolved module or unlinked crate `log`
126 |         log::error!("Failed to create session: {}", e);
    |
   --> src/api/auth/handlers/login.rs:126:9
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

    |             ^^^ use of unresolved module or unlinked crate `log`
110 |             log::error!("Failed to generate token: {}", e);
    |
   --> src/api/auth/handlers/login.rs:110:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

   |         ^^^ use of unresolved module or unlinked crate `log`
97 |         log::error!("Failed to update last login: {}", e);
   |
  --> src/api/auth/handlers/login.rs:97:9
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

   |             ^^^ use of unresolved module or unlinked crate `log`
87 |             log::error!("Password verification error: {}", e);
   |
  --> src/api/auth/handlers/login.rs:87:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

   |             ^^^ use of unresolved module or unlinked crate `log`
36 |             log::error!("Database error finding user: {}", e);
   |
  --> src/api/auth/handlers/login.rs:36:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

    |         ^^^ use of unresolved module or unlinked crate `log`
116 |         log::error!("Failed to create session: {}", e);
    |
   --> src/api/auth/handlers/register.rs:116:9
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

    |             ^^^ use of unresolved module or unlinked crate `log`
100 |             log::error!("Failed to generate token: {}", e);
    |
   --> src/api/auth/handlers/register.rs:100:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

   |         ^^^ use of unresolved module or unlinked crate `log`
81 |         log::error!("Failed to create user: {}", e);
   |
  --> src/api/auth/handlers/register.rs:81:9
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

   |             ^^^ use of unresolved module or unlinked crate `log`
60 |             log::error!("Failed to hash password: {}", e);
   |
  --> src/api/auth/handlers/register.rs:60:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

   |             ^^^ use of unresolved module or unlinked crate `log`
48 |             log::error!("Database error checking email: {}", e);
   |
  --> src/api/auth/handlers/register.rs:48:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `log`

  = help: if you wanted to use a crate named `async_trait`, use `cargo add async_trait` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
2 | use async_trait::async_trait;
  |
 --> src/storage/gcs_fuse.rs:2:5
error[E0432]: unresolved import `async_trait`

  = help: if you wanted to use a crate named `regex`, use `cargo add regex` to add it to your `Cargo.toml`
  |
  |     ^^^^^ use of unresolved module or unlinked crate `regex`
5 | use regex::Regex;
  |
 --> src/memory/privacy.rs:5:5
error[E0432]: unresolved import `regex`

   = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`
   |
   |             ^^^^^^ use of unresolved module or unlinked crate `base64`
94 |         use base64::{engine::general_purpose, Engine as _};
   |
  --> src/gateway/file_operations.rs:94:13
error[E0432]: unresolved import `base64`

   = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`
   |
   |             ^^^^^^ use of unresolved module or unlinked crate `base64`
83 |         use base64::{engine::general_purpose, Engine as _};
   |
  --> src/gateway/file_operations.rs:83:13
error[E0432]: unresolved import `base64`

   = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`
   |
   |             ^^^^^^ use of unresolved module or unlinked crate `base64`
94 |         use base64::{engine::general_purpose, Engine as _};
   |
  --> src/gateway/file_operations.rs:94:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`

  = help: if you wanted to use a crate named `validator`, use `cargo add validator` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^ use of unresolved module or unlinked crate `validator`
5 | use validator::Validate;
  |
 --> src/api/validation.rs:5:5
error[E0432]: unresolved import `validator`

   = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`
   |
   |             ^^^^^^ use of unresolved module or unlinked crate `base64`
83 |         use base64::{engine::general_purpose, Engine as _};
   |
  --> src/gateway/file_operations.rs:83:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`

  = help: if you wanted to use a crate named `validator`, use `cargo add validator` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^ use of unresolved module or unlinked crate `validator`
3 | use validator::{Validate, ValidationError};
  |
 --> src/api/schemas.rs:3:5
error[E0432]: unresolved import `validator`

  |
8 + use crate::services::Claims;
8 - use crate::api::auth::Claims;
  |
8 + use crate::minimal::auth::Claims;
8 - use crate::api::auth::Claims;
  |
8 + use crate::auth::Claims;
8 - use crate::api::auth::Claims;
  |
help: consider importing one of these structs instead
  |
  |     ^^^^^^^^^^^^^^^^^^^^^^^^ no `Claims` in `api::auth`
8 | use crate::api::auth::Claims;
  |
 --> src/api/handlers/session.rs:8:5
error[E0432]: unresolved import `crate::api::auth::Claims`

  = help: if you wanted to use a crate named `validator`, use `cargo add validator` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^ use of unresolved module or unlinked crate `validator`
9 | use validator::Validate;
  |
 --> src/api/handlers/execution_handlers.rs:9:5
error[E0432]: unresolved import `validator`

  = help: if you wanted to use a crate named `validator`, use `cargo add validator` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^ use of unresolved module or unlinked crate `validator`
9 | use validator::Validate;
  |
 --> src/api/handlers/agent_handlers.rs:9:5
error[E0432]: unresolved import `validator`

  = help: if you wanted to use a crate named `validator`, use `cargo add validator` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^ use of unresolved module or unlinked crate `validator`
4 | use validator::Validate;
  |
 --> src/api/auth/auth_types.rs:4:5
error[E0432]: unresolved import `validator`

  = help: if you wanted to use a crate named `validator`, use `cargo add validator` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^ use of unresolved module or unlinked crate `validator`
8 | use validator::Validate;
  |
 --> src/api/agent_models.rs:8:5
error[E0432]: unresolved import `validator`

  = help: if you wanted to use a crate named `async_trait`, use `cargo add async_trait` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
6 | use async_trait::async_trait;
  |
 --> src/ai/providers/openai.rs:6:5
error[E0432]: unresolved import `async_trait`

  = help: if you wanted to use a crate named `async_trait`, use `cargo add async_trait` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
6 | use async_trait::async_trait;
  |
 --> src/ai/providers/ollama.rs:6:5
error[E0432]: unresolved import `async_trait`

  = help: if you wanted to use a crate named `async_trait`, use `cargo add async_trait` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
6 | use async_trait::async_trait;
  |
 --> src/ai/providers/huggingface.rs:6:5
error[E0432]: unresolved import `async_trait`

  = help: if you wanted to use a crate named `async_trait`, use `cargo add async_trait` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
6 | use async_trait::async_trait;
  |
 --> src/ai/providers/gemini.rs:6:5
error[E0432]: unresolved import `async_trait`

  = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
7 | use reqwest::Client;
  |
 --> src/ai/providers/claude.rs:7:5
error[E0432]: unresolved import `reqwest`

  = help: if you wanted to use a crate named `async_trait`, use `cargo add async_trait` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
6 | use async_trait::async_trait;
  |
 --> src/ai/providers/claude.rs:6:5
error[E0432]: unresolved import `async_trait`

  = help: if you wanted to use a crate named `async_trait`, use `cargo add async_trait` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
8 | use async_trait::async_trait;
  |
 --> src/ai/mod.rs:8:5
error[E0432]: unresolved import `async_trait`

    = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`
    |
    |             ^^^^^^ use of unresolved module or unlinked crate `base64`
142 |         use base64::{engine::general_purpose, Engine as _};
    |
   --> src/services/token_service.rs:142:13
error[E0432]: unresolved import `base64`

    = help: if you wanted to use a crate named `rand_core`, use `cargo add rand_core` to add it to your `Cargo.toml`
    |
    |             ^^^^^^^^^ use of unresolved module or unlinked crate `rand_core`
115 |         use rand_core::{OsRng, RngCore};
    |
   --> src/services/token_service.rs:115:13
error[E0432]: unresolved import `rand_core`

    = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`
    |
    |             ^^^^^^ use of unresolved module or unlinked crate `base64`
142 |         use base64::{engine::general_purpose, Engine as _};
    |
   --> src/services/token_service.rs:142:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`

    = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`
    |
    |             ^^^^^^ use of unresolved module or unlinked crate `base64`
114 |         use base64::{engine::general_purpose, Engine as _};
    |
   --> src/services/token_service.rs:114:13
error[E0432]: unresolved import `base64`

  |                    ^^^^^^^^^^^^^^ no `ContextSummary` in `services::system_monitor::types`
7 | use super::types::{ContextSummary, ContextType};
  |
 --> src/services/system_monitor/context.rs:7:20
error[E0432]: unresolved import `super::types::ContextSummary`

    = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`
    |
    |             ^^^^^^ use of unresolved module or unlinked crate `base64`
114 |         use base64::{engine::general_purpose, Engine as _};
    |
   --> src/services/token_service.rs:114:13
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`

           crate::services::file_monitor::FileChangeEvent
   = help: consider importing this unresolved item through its public re-export instead:
           crate::services::event_capture::CaptureEvent
   = help: consider importing this unresolved item through its public re-export instead:
   |
   |                                     no `CaptureEvent` in `services`
   |                                     |
   |                                     ^^^^^^^^^^^^  ^^^^^^^^^^^^^^^ no `FileChangeEvent` in `services`
10 | use crate::services::{AuditService, CaptureEvent, FileChangeEvent};
   |
  --> src/services/system_monitor/metrics.rs:10:37
error[E0432]: unresolved imports `crate::services::CaptureEvent`, `crate::services::FileChangeEvent`

           std::fs::FileType
   = help: consider importing this struct instead:
           crate::storage::gcs_fuse::FileMetadata
   = help: consider importing this struct instead:
   |
   |     no `FileChangeEvent` in `services::file_monitor::types`
   |     |                no `FileContext` in `services::file_monitor::types`
   |     |                |            no `FileMetadata` in `services::file_monitor::types`
   |     |                |            |
   |     ^^^^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^                 ^^^^^^^^ no `FileType` in `services::file_monitor::types`
10 |     FileChangeEvent, FileContext, FileMetadata, FileOperation, FileType,
   |
  --> src/services/file_monitor/mod.rs:10:5
error[E0432]: unresolved imports `types::FileChangeEvent`, `types::FileContext`, `types::FileMetadata`, `types::FileType`

           std::fs::FileType
   = help: consider importing this struct instead:
           crate::storage::gcs_fuse::FileMetadata
   = help: consider importing this struct instead:
   |
   |                    no `FileChangeEvent` in `services::file_monitor::types`
   |                    |                no `FileContext` in `services::file_monitor::types`
   |                    |                |            no `FileMetadata` in `services::file_monitor::types`
   |                    |                |            |                            no `FileSnapshot` in `services::file_monitor::types`
   |                    |                |            |                            |
   |                    ^^^^^^^^^^^^^^^  ^^^^^^^^^^^  ^^^^^^^^^^^^                 ^^^^^^^^^^^^  ^^^^^^^^ no `FileType` in `services::file_monitor::types`
12 | use super::types::{FileChangeEvent, FileContext, FileMetadata, FileOperation, FileSnapshot, FileType};
   |
  --> src/services/file_monitor/operations.rs:12:20
error[E0432]: unresolved imports `super::types::FileChangeEvent`, `super::types::FileContext`, `super::types::FileMetadata`, `super::types::FileSnapshot`, `super::types::FileType`

  |                    no `FileChangeEvent` in `services::file_monitor::types`
  |                    |
  |                    ^^^^^^^^^^^^^^^  ^^^^^^^^^^^ no `FileContext` in `services::file_monitor::types`
9 | use super::types::{FileChangeEvent, FileContext, FileOperation};
  |
 --> src/services/file_monitor/detection.rs:9:20
error[E0432]: unresolved imports `super::types::FileChangeEvent`, `super::types::FileContext`

   |                    no `FileChangeEvent` in `services::file_monitor::types`
   |                    |
   |                    ^^^^^^^^^^^^^^^  ^^^^^^^^^^^^ no `FileSnapshot` in `services::file_monitor::types`
10 | use super::types::{FileChangeEvent, FileSnapshot};
   |
  --> src/services/file_monitor/core.rs:10:20
error[E0432]: unresolved imports `super::types::FileChangeEvent`, `super::types::FileSnapshot`

   |                    ^^^^^^^^^^^^^^^ no `FileChangeEvent` in `services::file_monitor::types`
14 | use super::types::{FileChangeEvent, FileOperation};
   |
  --> src/services/file_monitor/audit.rs:14:20
error[E0432]: unresolved import `super::types::FileChangeEvent`

   |                           +
11 |     AuthEventType, CapturedEvent, EventMetadata, FileOperation, SecuritySeverity, 
   |
help: a similar name exists in the module
   |
11 +     EventType, CaptureEvent, EventMetadata, FileOperation, SecuritySeverity, 
11 -     AuthEventType, CaptureEvent, EventMetadata, FileOperation, SecuritySeverity, 
   |
help: a similar name exists in the module
           crate::models::audit_event::SecuritySeverity
   = help: consider importing this enum instead:
           crate::services::FileOperation
           crate::models::agent_execution::FileOperation
           crate::memory::FileOperation
           crate::gateway::TerminalMessage::FileOperation
   = help: consider importing one of these items instead:
   |
   |     ^^^^^^^^^^^^^^^^^ no `WorkflowEventType` in `services::event_capture::types`
12 |     WorkflowEventType,
   |     no `AuthEventType` in `services::event_capture::types`
   |     |              no `CaptureEvent` in `services::event_capture::types`
   |     |              |                            no `FileOperation` in `services::event_capture::types`
   |     |              |                            |
   |     ^^^^^^^^^^^^^  ^^^^^^^^^^^^                 ^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^ no `SecuritySeverity` in `services::event_capture::types`
11 |     AuthEventType, CaptureEvent, EventMetadata, FileOperation, SecuritySeverity, 
   |
  --> src/services/event_capture/mod.rs:11:5
error[E0432]: unresolved imports `types::AuthEventType`, `types::CaptureEvent`, `types::FileOperation`, `types::SecuritySeverity`, `types::WorkflowEventType`

   |                                          +
16 | use super::types::{AuthEventType, CapturedEvent, FileOperation, SecuritySeverity, WorkflowEventType};
   |
help: a similar name exists in the module
   |
16 + use super::types::{EventType, CaptureEvent, FileOperation, SecuritySeverity, WorkflowEventType};
16 - use super::types::{AuthEventType, CaptureEvent, FileOperation, SecuritySeverity, WorkflowEventType};
   |
help: a similar name exists in the module
           crate::models::audit_event::SecuritySeverity
   = help: consider importing this enum instead:
           crate::services::FileOperation
           crate::models::agent_execution::FileOperation
           crate::memory::FileOperation
           crate::gateway::TerminalMessage::FileOperation
   = help: consider importing one of these items instead:
   |
   |                    no `AuthEventType` in `services::event_capture::types`
   |                    |              no `CaptureEvent` in `services::event_capture::types`
   |                    |              |             no `FileOperation` in `services::event_capture::types`
   |                    |              |             |              no `SecuritySeverity` in `services::event_capture::types`
   |                    |              |             |              |
   |                    ^^^^^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^ no `WorkflowEventType` in `services::event_capture::types`
16 | use super::types::{AuthEventType, CaptureEvent, FileOperation, SecuritySeverity, WorkflowEventType};
   |
  --> src/services/event_capture/processor.rs:16:20
error[E0432]: unresolved imports `super::types::AuthEventType`, `super::types::CaptureEvent`, `super::types::FileOperation`, `super::types::SecuritySeverity`, `super::types::WorkflowEventType`

  |     no `CaptureEvent` in `services::event_capture::types`
  |     |             help: a similar name exists in the module: `CapturedEvent`
  |     |             |
  |     ^^^^^^^^^^^^^^------------
8 | use super::types::CaptureEvent;
  |
 --> src/services/event_capture/core.rs:8:5
error[E0432]: unresolved import `super::types::CaptureEvent`

          crate::models::audit_event::SecuritySeverity
  = help: consider importing this enum instead:
  |
  |                    help: a similar name exists in the module: `CapturedEvent`
  |                    no `CaptureEvent` in `services::event_capture::types`
  |                    |
  |                    ^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^ no `SecuritySeverity` in `services::event_capture::types`
6 | use super::types::{CaptureEvent, SecuritySeverity};
  |
 --> src/services/event_capture/analytics.rs:6:20
error[E0432]: unresolved imports `super::types::CaptureEvent`, `super::types::SecuritySeverity`

  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `ControlResult` in `services::compliance_checks::types`
4 | use crate::services::compliance_checks::types::ControlResult;
  |
 --> src/services/compliance_checks/controls/gdpr.rs:4:5
error[E0432]: unresolved import `crate::services::compliance_checks::types::ControlResult`

  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `ControlResult` in `services::compliance_checks::types`
7 | use crate::services::compliance_checks::types::ControlResult;
  |
 --> src/services/compliance_checks/controls/soc2.rs:7:5
error[E0432]: unresolved import `crate::services::compliance_checks::types::ControlResult`

  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `ControlResult` in `services::compliance_checks::types`
2 | use crate::services::compliance_checks::types::ControlResult;
  |
 --> src/services/compliance_checks/gdpr.rs:2:5
error[E0432]: unresolved import `crate::services::compliance_checks::types::ControlResult`

  |                                                 no `Control` in `services::compliance_checks::types`
  |                                                 |
  |                                                 ^^^^^^^  ^^^^^^^^^^^^^ no `ControlResult` in `services::compliance_checks::types`
1 | use crate::services::compliance_checks::types::{Control, ControlResult};
  |
 --> src/services/compliance_checks/soc2.rs:1:49
error[E0432]: unresolved imports `crate::services::compliance_checks::types::Control`, `crate::services::compliance_checks::types::ControlResult`

  = help: if you wanted to use a crate named `rust_decimal`, use `cargo add rust_decimal` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^^ use of unresolved module or unlinked crate `rust_decimal`
2 | use rust_decimal::Decimal;
  |
 --> src/models/project/extensions/pmi.rs:2:5
error[E0432]: unresolved import `rust_decimal`

  = help: if you wanted to use a crate named `rust_decimal`, use `cargo add rust_decimal` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^^ use of unresolved module or unlinked crate `rust_decimal`
2 | use rust_decimal::Decimal;
  |
 --> src/models/project/core.rs:2:5
error[E0432]: unresolved import `rust_decimal`

    = help: if you wanted to use a crate named `sha2`, use `cargo add sha2` to add it to your `Cargo.toml`
    |
    |             ^^^^ use of unresolved module or unlinked crate `sha2`
573 |         use sha2::{Digest, Sha256};
    |
   --> src/models/audit_event.rs:573:13
error[E0432]: unresolved import `sha2`

  = help: if you wanted to use a crate named `log`, use `cargo add log` to add it to your `Cargo.toml`
  |
  |     ^^^ use of unresolved module or unlinked crate `log`
3 | use log::{debug, error, info, warn};
  |
 --> src/gateway/terminal_bridge/bridge.rs:3:5
error[E0432]: unresolved import `log`

  = help: if you wanted to use a crate named `dashmap`, use `cargo add dashmap` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^ use of unresolved module or unlinked crate `dashmap`
2 | use dashmap::DashMap;
  |
 --> src/gateway/terminal_bridge/bridge.rs:2:5
error[E0432]: unresolved import `dashmap`

  = help: if you wanted to use a crate named `log`, use `cargo add log` to add it to your `Cargo.toml`
  |
  |     ^^^ use of unresolved module or unlinked crate `log`
2 | use log::{debug, info};
  |
 --> src/gateway/file_operations.rs:2:5
error[E0432]: unresolved import `log`

  = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
5 | use reqwest::Client;
  |
 --> src/auth/oauth2_service.rs:5:5
error[E0432]: unresolved import `reqwest`

  = help: if you wanted to use a crate named `log`, use `cargo add log` to add it to your `Cargo.toml`
  |
  |     ^^^ use of unresolved module or unlinked crate `log`
5 | use log::{debug, trace};
  |
 --> src/auth/jwt.rs:5:5
error[E0432]: unresolved import `log`

  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `generate_jwt` in `services::token_service`
9 | use crate::services::token_service::generate_jwt;
  |
 --> src/api/handlers/auth/refresh.rs:9:5
error[E0432]: unresolved import `crate::services::token_service::generate_jwt`

   |            ^^^^^ could not find `types` in `super`
10 | use super::types::{AuditQueryParams, SuspiciousActivityReport};
   |
  --> src/api/handlers/audit/query.rs:10:12
error[E0432]: unresolved import `super::types`

  |            ^^^^^ could not find `types` in `super`
8 | use super::types::{
  |
 --> src/api/handlers/audit/compliance.rs:8:12
error[E0432]: unresolved import `super::types`

   |            ^^^^^ could not find `types` in `super`
11 | use super::types::{AuditEventSummary, ListAuditEventsQuery};
   |
  --> src/api/handlers/audit/basic.rs:11:12
error[E0432]: unresolved import `super::types`

  = help: if you wanted to use a crate named `regex`, use `cargo add regex` to add it to your `Cargo.toml`
  |
  |     ^^^^^ use of unresolved module or unlinked crate `regex`
5 | use regex::Regex;
  |
 --> src/ai/router/classifier.rs:5:5
error[E0432]: unresolved import `regex`

  = help: if you wanted to use a crate named `sha2`, use `cargo add sha2` to add it to your `Cargo.toml`
  |
  |     ^^^^ use of unresolved module or unlinked crate `sha2`
3 | use sha2::{Digest, Sha256};
  |
 --> src/services/file_monitor/operations.rs:3:5
error[E0432]: unresolved import `sha2`

  = help: if you wanted to use a crate named `tracing`, use `cargo add tracing` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^ use of unresolved module or unlinked crate `tracing`
7 | use tracing::{debug, info};
  |
 --> src/services/audit_service.rs:7:5
error[E0432]: unresolved import `tracing`

   = help: if you wanted to use a crate named `tokio_tungstenite`, use `cargo add tokio_tungstenite` to add it to your `Cargo.toml`
   |
   |     ^^^^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `tokio_tungstenite`
10 | use tokio_tungstenite::{accept_async, tungstenite::Message};
   |
  --> src/gateway/websocket_server_with_memory.rs:10:5
error[E0432]: unresolved import `tokio_tungstenite`

    = help: if you wanted to use a crate named `futures_util`, use `cargo add futures_util` to add it to your `Cargo.toml`
    |
    |         ^^^^^^^^^^^^ use of unresolved module or unlinked crate `futures_util`
124 |     use futures_util::future::LocalBoxFuture;
    |
   --> src/security/mod.rs:124:9
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `futures_util`

  = help: if you wanted to use a crate named `futures_util`, use `cargo add futures_util` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^^ use of unresolved module or unlinked crate `futures_util`
6 | use futures_util::future::{ok, LocalBoxFuture, Ready};
  |
 --> src/middleware/audit_middleware.rs:6:5
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `futures_util`

   = help: if you wanted to use a crate named `tokio_tungstenite`, use `cargo add tokio_tungstenite` to add it to your `Cargo.toml`
   |
   |     ^^^^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `tokio_tungstenite`
10 | use tokio_tungstenite::{accept_async, tungstenite::Message};
   |
  --> src/gateway/websocket_server_with_memory.rs:10:5
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio_tungstenite`

  = help: if you wanted to use a crate named `log`, use `cargo add log` to add it to your `Cargo.toml`
  |
  |     ^^^ use of unresolved module or unlinked crate `log`
4 | use log::{debug, error, info, warn};
  |
 --> src/gateway/websocket_server_with_memory.rs:4:5
error[E0432]: unresolved import `log`

  = help: if you wanted to use a crate named `futures_util`, use `cargo add futures_util` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^^ use of unresolved module or unlinked crate `futures_util`
3 | use futures_util::{SinkExt, StreamExt};
  |
 --> src/gateway/websocket_server_with_memory.rs:3:5
error[E0432]: unresolved import `futures_util`

  = help: if you wanted to use a crate named `dashmap`, use `cargo add dashmap` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^ use of unresolved module or unlinked crate `dashmap`
2 | use dashmap::DashMap;
  |
 --> src/gateway/websocket_server_with_memory.rs:2:5
error[E0432]: unresolved import `dashmap`

   = help: if you wanted to use a crate named `tokio_tungstenite`, use `cargo add tokio_tungstenite` to add it to your `Cargo.toml`
   |
   |     ^^^^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `tokio_tungstenite`
10 | use tokio_tungstenite::{accept_async, tungstenite::Message};
   |
  --> src/gateway/websocket_server.rs:10:5
error[E0432]: unresolved import `tokio_tungstenite`

   = help: if you wanted to use a crate named `tokio_tungstenite`, use `cargo add tokio_tungstenite` to add it to your `Cargo.toml`
   |
   |     ^^^^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `tokio_tungstenite`
10 | use tokio_tungstenite::{accept_async, tungstenite::Message};
   |
  --> src/gateway/websocket_server.rs:10:5
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio_tungstenite`

  = help: if you wanted to use a crate named `log`, use `cargo add log` to add it to your `Cargo.toml`
  |
  |     ^^^ use of unresolved module or unlinked crate `log`
4 | use log::{debug, error, info, warn};
  |
 --> src/gateway/websocket_server.rs:4:5
error[E0432]: unresolved import `log`

  = help: if you wanted to use a crate named `futures_util`, use `cargo add futures_util` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^^ use of unresolved module or unlinked crate `futures_util`
3 | use futures_util::{SinkExt, StreamExt};
  |
 --> src/gateway/websocket_server.rs:3:5
error[E0432]: unresolved import `futures_util`

  = help: if you wanted to use a crate named `dashmap`, use `cargo add dashmap` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^ use of unresolved module or unlinked crate `dashmap`
2 | use dashmap::DashMap;
  |
 --> src/gateway/websocket_server.rs:2:5
error[E0432]: unresolved import `dashmap`

  = help: if you wanted to use a crate named `tokio_fd`, use `cargo add tokio_fd` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^ use of unresolved module or unlinked crate `tokio_fd`
6 | use tokio_fd::AsyncFd;
  |
 --> src/gateway/terminal_bridge/stream.rs:6:5
error[E0432]: unresolved import `tokio_fd`

  = help: if you wanted to use a crate named `log`, use `cargo add log` to add it to your `Cargo.toml`
  |
  |     ^^^ use of unresolved module or unlinked crate `log`
2 | use log::{debug, error};
  |
 --> src/gateway/terminal_bridge/stream.rs:2:5
error[E0432]: unresolved import `log`

  = help: if you wanted to use a crate named `log`, use `cargo add log` to add it to your `Cargo.toml`
  |
  |     ^^^ use of unresolved module or unlinked crate `log`
3 | use log::{debug, error, info};
  |
 --> src/gateway/terminal_bridge/terminal_session.rs:3:5
error[E0432]: unresolved import `log`

  = help: if you wanted to use a crate named `nix`, use `cargo add nix` to add it to your `Cargo.toml`
  |
  |     ^^^ use of unresolved module or unlinked crate `nix`
5 | use nix::unistd::Pid;
  |
 --> src/gateway/terminal_bridge/terminal_session.rs:5:5
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `nix`

  = help: if you wanted to use a crate named `nix`, use `cargo add nix` to add it to your `Cargo.toml`
  |
  |     ^^^ use of unresolved module or unlinked crate `nix`
4 | use nix::sys::signal::{self, Signal};
  |
 --> src/gateway/terminal_bridge/terminal_session.rs:4:5
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `nix`

  = help: if you wanted to use a crate named `nix`, use `cargo add nix` to add it to your `Cargo.toml`
  |
  |     ^^^ use of unresolved module or unlinked crate `nix`
2 | use nix::libc;
  |
 --> src/gateway/terminal_bridge/pty.rs:2:5
error[E0432]: unresolved import `nix`

  = help: if you wanted to use a crate named `nix`, use `cargo add nix` to add it to your `Cargo.toml`
  |
  |     ^^^ use of unresolved module or unlinked crate `nix`
5 | use nix::unistd::{close, dup2, execvp, fork, setsid, ForkResult, Pid};
  |
 --> src/gateway/terminal_bridge/pty.rs:5:5
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `nix`

  = help: if you wanted to use a crate named `nix`, use `cargo add nix` to add it to your `Cargo.toml`
  |
  |     ^^^ use of unresolved module or unlinked crate `nix`
4 | use nix::sys::termios::{self, SetArg};
  |
 --> src/gateway/terminal_bridge/pty.rs:4:5
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `nix`

  = help: if you wanted to use a crate named `nix`, use `cargo add nix` to add it to your `Cargo.toml`
  |
  |     ^^^ use of unresolved module or unlinked crate `nix`
3 | use nix::pty::{openpty, OpenptyResult, Winsize};
  |
 --> src/gateway/terminal_bridge/pty.rs:3:5
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `nix`

   |            ^^^^^^^ could not find `session` in `super`
11 | use super::session::TerminalSession;
   |
  --> src/gateway/terminal_bridge/bridge.rs:11:12
error[E0432]: unresolved import `super::session`

  = help: if you wanted to use a crate named `tokio_tungstenite`, use `cargo add tokio_tungstenite` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `tokio_tungstenite`
6 | use tokio_tungstenite::WebSocketStream;
  |
 --> src/gateway/connection.rs:6:5
error[E0432]: unresolved import `tokio_tungstenite`

  |                    ^^^^^^^ could not find `session` in `models`
2 | use crate::models::session::{
  |
 --> src/db/repositories/session_repository.rs:2:20
error[E0432]: unresolved import `crate::models::session`

  = help: if you wanted to use a crate named `tokio_tungstenite`, use `cargo add tokio_tungstenite` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `tokio_tungstenite`
5 | use tokio_tungstenite::tungstenite::Message;
  |
 --> src/gateway/connection.rs:5:5
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio_tungstenite`

  = help: if you wanted to use a crate named `futures_util`, use `cargo add futures_util` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^^ use of unresolved module or unlinked crate `futures_util`
1 | use futures_util::stream::SplitSink;
  |
 --> src/gateway/connection.rs:1:5
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `futures_util`

   = help: if you wanted to use a crate named `rand_core`, use `cargo add rand_core` to add it to your `Cargo.toml`
   |
   |         ^^^^^^^^^ use of unresolved module or unlinked crate `rand_core`
37 |     use rand_core::OsRng;
   |
  --> src/api/handlers/user.rs:37:9
error[E0432]: unresolved import `rand_core`

  = help: if you wanted to use a crate named `futures_util`, use `cargo add futures_util` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^^ use of unresolved module or unlinked crate `futures_util`
7 | use futures_util::future::{ok, LocalBoxFuture, Ready};
  |
 --> src/auth/jwt_middleware.rs:7:5
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `futures_util`

  = help: if you wanted to use a crate named `futures_util`, use `cargo add futures_util` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^^^^ use of unresolved module or unlinked crate `futures_util`
5 | use futures_util::future::LocalBoxFuture;
  |
 --> src/api/middleware/rate_limit.rs:5:5
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `futures_util`

  |            help: a similar path exists: `actix_web::error`
  |            unresolved import
  |            |
  |            ^^^^^
9 | use crate::error::ApiError;
  |
 --> src/api/handlers/session.rs:9:12
error[E0432]: unresolved import `crate::error`

  = help: if you wanted to use a crate named `validator`, use `cargo add validator` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^ use of unresolved module or unlinked crate `validator`
3 | use validator::Validate;
  |
 --> src/api/auth/handlers/profile.rs:3:5
error[E0432]: unresolved import `validator`

   |                    ^^^^^^^ could not find `session` in `models`
10 | use crate::models::session::Session as DbSession;
   |
  --> src/api/auth/handlers/login.rs:10:20
error[E0432]: unresolved import `crate::models::session`

  = help: if you wanted to use a crate named `validator`, use `cargo add validator` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^ use of unresolved module or unlinked crate `validator`
3 | use validator::Validate;
  |
 --> src/api/auth/handlers/login.rs:3:5
error[E0432]: unresolved import `validator`

   |                    ^^^^^^^ could not find `session` in `models`
10 | use crate::models::session::Session as DbSession;
   |
  --> src/api/auth/handlers/register.rs:10:20
error[E0432]: unresolved import `crate::models::session`

  = help: if you wanted to use a crate named `validator`, use `cargo add validator` to add it to your `Cargo.toml`
  |
  |     ^^^^^^^^^ use of unresolved module or unlinked crate `validator`
3 | use validator::Validate;
  |
 --> src/api/auth/handlers/register.rs:3:5
error[E0432]: unresolved import `validator`
   Compiling coditect-minimal-api v0.1.0 (/app)