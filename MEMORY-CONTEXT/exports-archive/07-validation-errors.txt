# Build Error Chunk Metadata
# ==========================
# Source File: Google-Cloud-BUILD-ERRORS.2025-09-22.txt
# Total Lines in Source: 4550
# Chunk Number: 7
# Lines in This Chunk: 500
# Start Line: 2851
# End Line: 3350
# Overlap: 25 lines (5%)
# Generated: 2025-09-22 15:38:35 UTC
# Purpose: Rust compilation errors from Google Cloud Build
# Error Count: 346 total compilation errors
#
# ==========================

    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                                               ^^^^^ `ai::AIProvider` is not dyn compatible
 61 |         let providers = self.providers.read().await;
    |
   --> src/ai/router/mod.rs:61:47
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                         ^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
 61 |         let providers = self.providers.read().await;
    |
   --> src/ai/router/mod.rs:61:25
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
 46 |         self.providers.write().await.insert(provider_type, provider);
    |
   --> src/ai/router/mod.rs:46:9
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                                ^^^^^ `ai::AIProvider` is not dyn compatible
 46 |         self.providers.write().await.insert(provider_type, provider);
    |
   --> src/ai/router/mod.rs:46:32
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |         ^^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
 46 |         self.providers.write().await.insert(provider_type, provider);
    |
   --> src/ai/router/mod.rs:46:9
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

    = note: `ai::AIProvider` may be implemented in other crates; if you want to support your users passing their own types here, you can't refer to a specific type
            implementing `ai::AIProvider` for this new enum and using it instead
            consider defining an enum where each variant holds one of these types,
              ai::providers::openai::OpenAIProvider
              ai::providers::ollama::OllamaProvider
              ai::providers::huggingface::HuggingFaceProvider
              ai::providers::gemini::GeminiProvider
              ai::providers::claude::ClaudeProvider
    = help: the following types implement `ai::AIProvider`:
    = help: consider moving `list_models` to another trait
    = help: consider moving `check_availability` to another trait
    = help: consider moving `execute_with_model` to another trait
    = help: consider moving `execute` to another trait
    |              ^^^^^^^^^^^ ...because method `list_models` is `async`
236 |     async fn list_models(&self) -> Result<Vec<ModelInfo>>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `check_availability` is `async`
233 |     async fn check_availability(&self) -> Result<ProviderStatus>;
...
    |              ^^^^^^^^^^^^^^^^^^ ...because method `execute_with_model` is `async`
226 |     async fn execute_with_model(
...
    |              ^^^^^^^ ...because method `execute` is `async`
223 |     async fn execute(&self, request: &AIRequest) -> Result<AIResponse>;
...
    |           ---------- this trait is not dyn compatible...
209 | pub trait AIProvider: Send + Sync {
    |
   --> src/ai/mod.rs:223:14
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
note: for a trait to be dyn compatible it needs to allow building a vtable
    |
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^ `ai::AIProvider` is not dyn compatible
 45 |         let provider_type = provider.provider_type();
    |
   --> src/ai/router/mod.rs:45:29
error[E0038]: the trait `ai::AIProvider` is not dyn compatible

  |     ^^^^^^^^^^^
2 | use chrono::Utc;
  |
 --> src/services/system_monitor/alerts.rs:2:5
warning: unused import: `chrono::Utc`

  |              ^^^^^^
1 | use anyhow::{anyhow, Result};
  |
 --> src/services/event_capture/processor.rs:1:14
warning: unused import: `anyhow`

  |     ^^^^^^^^^^^^^^
1 | use anyhow::Result;
  |
 --> src/services/event_capture/analytics.rs:1:5
warning: unused import: `anyhow::Result`

   |                               ^^^^^^^^^^^^^^
12 |     audit_event::{AuditEvent, AuditEventType},
   |
  --> src/services/audit_service.rs:12:31
warning: unused import: `AuditEventType`

  = note: `#[warn(unused_doc_comments)]` on by default
  = help: to document an item produced by a macro, the macro must produce the documentation as part of its expansion
  |
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ rustdoc does not generate documentation for macro invocations
6 | /// Thread-local storage for tenant context
  |
 --> src/security/tenant_isolation.rs:6:1
warning: unused doc comment

  = note: `#[warn(unexpected_cfgs)]` on by default
  = note: see <https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html> for more information about checking conditional configuration
  = help: consider adding `integration-examples` as a feature in `Cargo.toml`
  = note: no expected values for `feature`
  |
  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove the condition
6 | #[cfg(feature = "integration-examples")]
  |
 --> src/security/mod.rs:6:7
warning: unexpected `cfg` condition value: `integration-examples`

  |              ^^^^^^^^  ^^^
1 | use chrono::{DateTime, Utc};
  |
 --> src/models/project/extensions/pmi.rs:1:14
warning: unused imports: `DateTime` and `Utc`

  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
4 | use std::collections::HashMap;
  |
 --> src/models/project/core.rs:4:5
warning: unused import: `std::collections::HashMap`

  |              ^^^^^^^^
4 | use chrono::{DateTime, Utc, Duration};
  |
 --> src/minimal/auth.rs:4:14
warning: unused import: `DateTime`

  |                                                   ^^^^^^
1 | use actix_web::{error, HttpRequest, HttpResponse, Result};
  |
 --> src/api/middleware/json_error_handler.rs:1:51
warning: unused import: `Result`

  |                           ^^^^^^^^
8 | use crate::models::{User, UserRole};
  |
 --> src/api/handlers/user.rs:8:27
warning: unused import: `UserRole`

  |                     ^^^^  ^^^^^^^  ^^^^  ^^^^^^  ^^^^^^^^^^
7 | use crate::models::{User, Project, Task, Entity, Subsidiary};
  |
 --> src/api/handlers/test.rs:7:21
warning: unused imports: `Entity`, `Project`, `Subsidiary`, `Task`, and `User`

   |                                                       ^^^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^
11 | use crate::models::{ProjectMember, ProjectRole, Task, TaskPriority, TaskStatus, TaskType};
   |
  --> src/api/handlers/task.rs:11:55
warning: unused imports: `TaskPriority`, `TaskStatus`, and `TaskType`

  |                                 ^^^^^^^^^^^^^^^^
8 | use crate::models::{Subsidiary, SubsidiaryStatus};
  |
 --> src/api/handlers/subsidiary.rs:8:33
warning: unused import: `SubsidiaryStatus`

  |                              ^^^^^^^^^^^^^  ^^^^^^^^^^^
7 | use crate::models::{Project, ProjectStatus, ProjectType};
  |
 --> src/api/handlers/project.rs:7:30
warning: unused imports: `ProjectStatus` and `ProjectType`

  |     ^^^^^^^^^^^^^^^^^^^^
6 | use crate::api::ApiError;
  |
 --> src/api/handlers/audit/basic.rs:6:5
warning: unused import: `crate::api::ApiError`

  = note: `#[warn(unused_imports)]` on by default
  |
  |                           ^^^^^^^^
6 | use crate::models::{User, UserRole};
  |
 --> src/api/auth/auth_types.rs:6:27
warning: unused import: `UserRole`

   |
85 +         severity: SecuritySeverity,
85 -         severity: super::types::SecuritySeverity,
   |
help: if you import `SecuritySeverity`, refer to it directly
   |
 1 + use crate::models::audit_event::SecuritySeverity;
   |
help: consider importing this enum
   |
   |                                 ^^^^^^^^^^^^^^^^ not found in `super::types`
85 |         severity: super::types::SecuritySeverity,
   |
  --> src/services/event_capture/core.rs:85:33
error[E0412]: cannot find type `SecuritySeverity` in module `super::types`

   |
 1 + use actix_web::mime;
   |
help: consider importing this crate
   = help: if you wanted to use a crate named `mime`, use `cargo add mime` to add it to your `Cargo.toml`
   |
   |                                      ^^^^ use of unresolved module or unlinked crate `mime`
49 |                 && mime.subtype() == mime::JSON
   |
  --> src/api/middleware/json_error_handler.rs:49:38
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `mime`

   |
 1 + use actix_web::mime;
   |
help: consider importing this crate
   = help: if you wanted to use a crate named `mime`, use `cargo add mime` to add it to your `Cargo.toml`
   |
   |                             ^^^^ use of unresolved module or unlinked crate `mime`
48 |             mime.type_() == mime::APPLICATION
   |
  --> src/api/middleware/json_error_handler.rs:48:29
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `mime`

    |
367 +     body: web::Json<UpdateProfileRequest>,
367 -     body: web::Json<crate::api::dto::UpdateProfileRequest>,
    |
help: if you import `UpdateProfileRequest`, refer to it directly
    |
  1 + use crate::api::dto::auth::UpdateProfileRequest;
    |
  1 + use crate::api::auth::UpdateProfileRequest;
    |
help: consider importing one of these structs
    |
367 +     body: web::Json<crate::api::dto::UpdateProjectRequest>,
367 -     body: web::Json<crate::api::dto::UpdateProfileRequest>,
    |
help: a struct with a similar name exists
    |
    | ------------------------------- similarly named struct `UpdateProjectRequest` defined here
 20 | pub struct UpdateProjectRequest {
    |
   ::: src/api/dto/project.rs:20:1
    |
    |                                      ^^^^^^^^^^^^^^^^^^^^
367 |     body: web::Json<crate::api::dto::UpdateProfileRequest>,
    |
   --> src/api/handlers/user.rs:367:38
error[E0412]: cannot find type `UpdateProfileRequest` in module `crate::api::dto`

    |
328 +             let profile = UserProfile {
328 -             let profile = crate::api::dto::UserProfile {
    |
help: if you import `UserProfile`, refer to it directly
    |
  1 + use crate::api::dto::auth::UserProfile;
    |
  1 + use crate::api::auth::UserProfile;
    |
help: consider importing one of these structs
    |
    |                                            ^^^^^^^^^^^ not found in `crate::api::dto`
328 |             let profile = crate::api::dto::UserProfile {
    |
   --> src/api/handlers/user.rs:328:44
error[E0422]: cannot find struct, variant or union type `UserProfile` in module `crate::api::dto`

    |
267 +     body: web::Json<UpdateProfileRequest>,
267 -     body: web::Json<crate::api::dto::UpdateProfileRequest>,
    |
help: if you import `UpdateProfileRequest`, refer to it directly
    |
  1 + use crate::api::dto::auth::UpdateProfileRequest;
    |
  1 + use crate::api::auth::UpdateProfileRequest;
    |
help: consider importing one of these structs
    |
267 +     body: web::Json<crate::api::dto::UpdateProjectRequest>,
267 -     body: web::Json<crate::api::dto::UpdateProfileRequest>,
    |
help: a struct with a similar name exists
    |
    | ------------------------------- similarly named struct `UpdateProjectRequest` defined here
 20 | pub struct UpdateProjectRequest {
    |
   ::: src/api/dto/project.rs:20:1
    |
    |                                      ^^^^^^^^^^^^^^^^^^^^
267 |     body: web::Json<crate::api::dto::UpdateProfileRequest>,
    |
   --> src/api/handlers/user.rs:267:38
error[E0412]: cannot find type `UpdateProfileRequest` in module `crate::api::dto`

    |
231 +             let profile = UserProfile {
231 -             let profile = crate::api::dto::UserProfile {
    |
help: if you import `UserProfile`, refer to it directly
    |
  1 + use crate::api::dto::auth::UserProfile;
    |
  1 + use crate::api::auth::UserProfile;
    |
help: consider importing one of these structs
    |
    |                                            ^^^^^^^^^^^ not found in `crate::api::dto`
231 |             let profile = crate::api::dto::UserProfile {
    |
   --> src/api/handlers/user.rs:231:44
error[E0422]: cannot find struct, variant or union type `UserProfile` in module `crate::api::dto`

   |                        ^^^^^^^^^^^^^^^^^ not found in `crate::auth`
26 |     auth: crate::auth::AuthenticatedUser,
   |
  --> src/api/handlers/session.rs:26:24
error[E0412]: cannot find type `AuthenticatedUser` in module `crate::auth`

    |                                                ---- variable not in all patterns
180 |                 AuditEventType::Authentication(auth) if matches!(auth.action, AuthAction::LoginFailed { .. })
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern doesn't bind `auth`
179 |                 AuditEventType::SecurityEvent(_) |
    |
   --> src/services/compliance_checks/controls/soc2.rs:179:17
error[E0408]: variable `auth` is not bound in all patterns

   = help: if you wanted to use a crate named `lru`, use `cargo add lru` to add it to your `Cargo.toml`
   |
   |                                                    ^^^ use of unresolved module or unlinked crate `lru`
33 |             redaction_cache: std::sync::Mutex::new(lru::LruCache::new(
   |
  --> src/memory/privacy.rs:33:52
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `lru`

    = help: if you wanted to use a crate named `regex`, use `cargo add regex` to add it to your `Cargo.toml`
    |
    |                                 ^^^^^ use of unresolved module or unlinked crate `regex`
187 |                 if let Ok(re) = regex::Regex::new(&format!("^{}$", pattern)) {
    |
   --> src/memory/capture.rs:187:33
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `regex`

    = help: if you wanted to use a crate named `regex`, use `cargo add regex` to add it to your `Cargo.toml`
    |
    |                             ^^^^^ use of unresolved module or unlinked crate `regex`
173 |             if let Ok(re) = regex::Regex::new(pattern) {
    |
   --> src/memory/capture.rs:173:29
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `regex`

